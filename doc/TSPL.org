#+TITLE: The Scheme Programming Language Learning Note
#+AUTHOR: R. Kent Dybvig
#+STARTUP: indent

* Preface(序言)
https://www.scheme.com/tspl4/
Scheme was introduced in 1975
First dialect of List of full support:
- lexical scoping
- first-class procedures
- continuations

* 1. Introduction(引言)
** Introduction
Scheme is a general-purpose computer programming language.
It is a high-level language,
While Scheme is often identified with symbolic applications, 
its rich set of data types and flexible control structures make it a truly versatile language. 
*** Employed to write:
- text editors, 
- optimizing compilers, 
- operating systems, 
- graphics packages, 
- expert systems, 
- numerical applications, 
- financial analysis packages, 
- virtual reality systems, 
- and practically every other type of application imaginable.
*** Value supports
Scheme supports many types of data values, or objects, 
including characters, strings, *symbols*, lists or vectors of objects, and a full set of numeric data types, 
including *complex, real, and arbitrary-precision rational numbers*.
*** Memory Manager
Typically by a *garbage collector* that periodically recovers the storage used by inaccessible objects.
Simple atomic values, such as small integers, characters, booleans, and the empty list, 
are typically represented as *immediate values* and thus incur *no allocation or deallocation overhead*.
*** Objects are First-class data values
because they are retained indefinitely, 无限期保留
they may be passed freely as arguments to procedures, 它们可以作为参数自由传递给过程
returned as values from procedures, 作为过程的值返回
and combined to form new objects. 组合成新的物体

This is in contrast with many other languages where composite data values 对比其他语言
such as arrays are either statically allocated and never deallocated, 静态分配,从不释放
allocated on entry to a block of code and unconditionally deallocated on exit from the block, 在进入代码块时分配，在退出代码块时无条件地释放
or explicitly allocated and deallocated by the programmer. 由程序员显式地分配和释放。
*** Scheme is a call-by-value 值调用语言
These pointers remain behind the scenes, 
however, and programmers need not be conscious of them except to understand that the storage for an object is 
not copied when an object is passed to or returned from a procedure. 当向过程传递对象或从过程返回对象时，不会复制对象
*** Small core of *syntacti*c forms 小核心语法
These core forms, a set of extended syntactic forms derived from them, 从它们衍生出来的一组扩展的句法形式
and a set of primitive procedures make up the full Scheme language. 一组基本过程构成了完整的Scheme语言

An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. 
Scheme的解释器或编译器可以非常小，而且可能非常快和高可靠。

The extended syntactic forms and many primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.
扩展的语法形式和许多原始过程可以在Scheme中定义，从而简化了实现，提高了可靠性。
*** Printed *representation*
Scheme programs share a common printed representation with Scheme data structures.
Scheme程序与Scheme数据结构共享一个公共的打印表示。
As a result, any Scheme program has a natural and obvious internal representation as a Scheme object. 
因此，任何Scheme程序都具有作为Scheme对象的自然和明显的内部表示。

For example, 
variables and syntactic keywords correspond to symbols, 变量和语法关键字对应符号
while structured syntactic forms correspond to lists. 而结构化语法形式对应于列表

This representation is the basis for the syntactic extension facilities provided by Scheme 
for the definition of new syntactic forms in terms of existing syntactic forms and procedures.
这种表示是Scheme提供的语法扩展功能的基础，这些功能可以根据现有的语法形式和过程定义新的语法形式

It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, 
as well as program transformation tools for other languages in Scheme.
它还促进了Scheme中解释器、编译器和其他程序转换工具的直接实现，以及Scheme中其他语言的程序转换工具的实现。
*** Scheme variables and keywords are *lexically scoped*, and Scheme programs are *block-structured*
Scheme变量和关键字是 *词法作用域* ，Scheme程序是 *块结构* 的。

QUESTION: 标识符的具体定义?
ANSWER: see 1.1.Scheme Syntax
*Identifiers* may be imported into a program or library or bound locally within a given block of code such as a library, program, or procedure body. 
*标识符* 可以导入到程序或库中，也可以在给定的代码块(如库、程序或过程体)中本地绑定。

A *local binding* is visible only lexically, i.e., within the program text that makes up the particular block of code. 
局部绑定只在词汇上可见，也就是说，在组成特定代码块的程序文本中可见。

An occurrence of an identifier of the same name outside this block refers to a different binding;
在此块之外出现同名的标识符就会指向不同的绑定;

if no binding for the identifier exists outside the block, then the reference is invalid.
如果该标识符在块外不存在绑定，则引用无效。

Blocks may be nested, and a binding in one block may shadow a binding for an identifier of the same name in a surrounding block. 
块可能是嵌套的，一个块中的绑定可能会在周围块中隐藏同名标识符的绑定。

The scope of a binding is the block in which the bound identifier is visible minus any portions of the block in which the identifier is shadowed.
绑定的作用域是绑定标识符可见的块减去隐藏标识符的块的任何部分。

Block structure and lexical scoping help create programs that are modular, easy to read, easy to maintain, and reliable.
块结构和词法作用域有助于创建模块化、易于阅读、易于维护和可靠的程序。

Efficient code for lexical scoping is possible because a compiler can determine before program evaluation the scope of all bindings and the binding to which each identifier reference resolves.
词法作用域的有效代码是可能的，因为编译器可以在程序求值之前确定所有绑定的作用域和每个标识符引用所解析的绑定。

This does not mean, of course, that a compiler can determine the values of all variables, since the actual values are not computed in most cases until the program executes.
当然，这并不意味着编译器可以确定所有变量的值，因为在大多数情况下，直到程序执行时才会计算实际的值。
*** *Procedure* in many language
1. a procedure definition is simply the association of a name with a block of code.
   Certain variables local to the block are the parameters of the procedure. In some languages,
2. a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block.
3. procedures can be defined only at top level.
4. *In Scheme* 
   - a procedure definition may appear within another block or procedure, 过程定义可能出现在另一个块或过程中
     and the procedure may be invoked at any time thereafter, 这个过程可以在此后的任何时间被调用，
     even if the enclosing block has completed its execution. 即使这个封闭块已经完成了它的执行。
     To support lexical scoping, a procedure carries the lexical context (environment) along with its code. 
     为了支持词法作用域，过程在其代码中附带词法上下文(环境)。

   - Scheme procedures are not always named. 方案过程并不总是被命名。
     Instead, procedures are first-class data objects like strings or numbers, and variables are bound to procedures in the same way they are bound to other objects.
     相反，过程是像字符串或数字一样的一级数据对象，变量与过程的绑定方式与与其他对象的绑定方式相同。
     TIP: 过程是一等对象,可以不需要命名

   - Scheme procedures may be recursive
     方案过程可能是递归的
     A special case of recursion, called tail recursion, is used to express iteration, or looping. 
     递归的一种特殊情况称为尾部递归，用于表示迭代或循环。
     
     A *tail call* occurs when one procedure directly returns the result of invoking another procedure;
     当一个过程直接返回调用另一个过程的结果时，就会发生尾部调用;
     
     *tail recursion* occurs when a procedure recursively tail-calls itself, directly or indirectly.
     当一个过程直接或间接地递归地尾部调用自己时，就会发生尾部递归。
     
     Scheme implementations are required to implement tail calls as jumps (gotos),
     so the storage overhead normally associated with recursion is avoided. 
     模式实现需要将尾部调用实现为跳转(gotos)，因此避免了通常与递归相关的存储开销。
     
     As a result, Scheme programmers need master only simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.
     TIP: 因此，Scheme程序员只需要掌握简单的过程调用和递归，而不需要处理常见的各种循环结构。
*** Scheme supports the definition of *arbitrary control structures* with *continuations*
A continuation is a *procedure* that embodies the remainder of a program at a given point in the program. 
continuation是一个过程，它包含程序中给定点上的剩余部分。

A continuation may be obtained at any time during the execution of a program. 
在程序执行期间的任何时候都可以获得continuation。

As with other procedures, a continuation is a first-class object and may be invoked at any time after its creation.
与其他过程一样，continuation是一级对象，可以在创建后的任何时候调用

Whenever it is invoked, the program immediately continues from the point where the continuation was obtained.
无论何时调用它，程序都会立即从获得延续的点开始继续。

Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.
延续允许实现复杂的控制机制，包括显式回溯、多线程和协程。
*** Scheme also allows programmers to define new *syntactic forms, or syntactic extensions*,  
by writing *transformation procedures* that determine how each new syntactic form maps to existing syntactic forms.

These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. 
这些转换过程本身在Scheme中表示，借助一种方便的高级模式语言，可以自动进行语法检查、输入解析和输出重构。

By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer.
默认情况下，词法作用域是通过转换过程来维护的，但是程序员可以控制出现在转换器输出中的所有标识符的作用域。

Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme.
语法扩展对于定义新的语言构造、模拟其他语言中的语言构造、实现内联代码扩展的效果、甚至在Scheme中模拟整个语言都很有用。

Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.
大多数大型Scheme程序都是混合使用语法扩展和过程定义构建的。
*** Scheme parents
**** Lisp
Scheme inherited from Lisp the treatment of values as first-class objects, 
several important data types, including symbols and lists, and the representation of programs as objects, among other things.
Scheme从Lisp继承了将值处理为第一类对象、一些重要的数据类型(包括符号和列表)以及将程序表示为对象等特性。
**** Algol
Lexical scoping and block structure are features taken from Algol
**** Dialect Lisp
Scheme was the first Lisp dialect to adopt lexical scoping and block structure, first-class procedures, the treatment of tail calls as jumps, continuations, and lexically scoped syntactic extensions.
Scheme是第一个采用词法作用域和块结构、一级过程、将尾部调用处理为跳转、延续和词法作用域的句法扩展的Lisp方言。
** 1.1.Scheme Syntax(语法)
*** First study
   Scheme programs _are make up of_ *keyworkd(关键字),variables(变量),structed 
forms(结构化形式), constant data(常量数据), whitespace(空白符) and comments注*
*释.)*
Keyword, variables and symbols are collectively(全体/共同地) called identifiers
关键字，变量和符号统称为标识符。
**** *标识符*
*Identifiers* maybe formed from letters, digits, and certain specifial characte
rsinclude ?!.+-*/<=>:$%^_!@, as well as a setof additionall unicode characeers.
标识符有字母，数字，某些特殊字符 和 Unicode字符。
Identifiers can not start with at sign(@) and normally cannot start with any ch
aracters that can start a number, i.e, a dibit, plus sign(+), minus sign(-), or
decimal point(.).
标识符不能以@,+,-,.开头
Eacheptions ares +, -, and ..., which are valid identifires.
+,-,... 是合法标识符。
and any identifier starting with *->* are all identifiers.
任何以 *->* 开始的都是标识符。
*Identifiers* *are delimited* by whitespace, comments, parentheses, brackets, strin
g(double)quotes("), and hash marks(#).
*标识符* 由 *空白符、注释、圆括号、括号、双引号字符串、哈希标记* 分割。
A delimited or any other Unicode character may be-included any where within the
name of an identifier as an escape of the form _\xsv_, where _sv_ is the scalar
value of the character in hexadecimal natation.
标识符内任何地方可以使用逃逸字符\xsv表示，sv是十六进制数值。
There is no inherent limit on the length of a Scheme identifier;
标识符长度不限；
programmers may use as many characters as necessary.
程序员可以使用必要多的字符。
Long identifiers are no substitute for comments,
长的标识符不能替代注释，
however, and frequent use of long identifiers can make a program difficult to
format and consequently(因此) difficult to read.
然而，频繁使用长标识符会使程序难格式化也因此难以阅读。
*不建议使用长标识符* 
A good rule to use a short identifiers when the scope of identifer is small and
longer identifiers when the scope is larger.
一个好的规则是，小作用域使用短标识符，大作用域使用长标识符。
Identifiers may *be written* in any mix of upper- and lower-case letters, and 
*case is significant(重要/有意义的)*,i.e, For example, abcde, Abcde,AbCDe all 
refer to different identifiers. This is a change from previous versions of the 
Revised Report.
标识符是 *大小写敏感* 的，这是一个不同于以前修订报告。
**** *列表、向量*
Structured forms and list constants *are enclosed within parenthese*, e.g., (a 
b c) or (* (- x 2) y). The empty list *is written ()*.
结构化形式和列表常量使用圆括号包含起来.
Matched sets of brackets([]) may *be used* in place of parentheses and are ofte
n used to set off the subexpressions of certain standards syntactic forms for r
eadability, as shown in examples througout this book.
配对的方括号用于在子表达式中替代圆括号，提高句法的可读性。
Vectors *are written* similary to list, except that they *are preceded* by #(and
 terminated by), e.g., #(this is a vector of symbols).
*向量* 类似列表，但头部(尾部)增加 # 。
Bytevectors *are written* as sequences of unsigned byte values(exact integers 
in  the range 0 through 255) bracketed by *#vu8(...)*, e.g., *#vu8(30 255 46 
78)*.
*字节向量* 以 #vu8 打头 包含 0~255 的数值。

**** Strings(字符串)  and Numbers(数值)
Strings *are enclosed* in double quotation marks, e.g.,"I am a string".
*字符串* 使用双引号包含。
*Characters are preceded by #\, e.g, #\a.*
*字符* 使用 *#\* 前缀，如 #\a 表示字符 a。
Case is important within character and stirng constants, as within identifiers.
和标识符一样，字符串常量和字符常量是 *大小写敏感* 的。
*Numbers* may *be written as integers*, e.g, -123, *as ratios*,e.g, 1/2, in *fl
oating-point* or *scientific notation*,e.g.,1.3 or 1e23, or as *complex number
s in rectangular or polar notations*,e.g.,1.3-2.7i or -1.2@73.
*数值* 表示方式如 *整数* *有理数* *浮点数* *科学表示法* *复数(矩形坐标、极坐标
)* 
Case is not important in the syntax of a number.
*数值表示不区分大小写(大小写不敏感)*
The *boolean* values representing _true_ and _false_ *are written* #t and #f.
*bool 值表示 _真_ _假_ 写成 #t 和 #f*
Scheme conditional expressions actually treat #f as false and all other object
as true, so 3, 0, (), "false" and nil all *count as当作* true.
*Scheme 条件表达式非 #f 即为真*
Details of the syntax for each type of constant data *are given* in the individ
ual sections of Character 6 and the formal syntax of Scheme starting on page 45
5.
常数据语法在第六章，形式语法在455页后又详细介绍。
**** Scheme expressions(表达式) and Comments(注释)
*Scheme expressions* may span several lines, and no explicit terminator is requ
ired.
*Scheme 表达式* 可以跨越多行，并且没有明确的结束限定。
Since the number of whitespace characters(space and newlines) between expressio
ns is not sinificat(总要), Scheme programs *should be intended* to show the str
ucture of the code in a way that makes the code as readable as possible.
由于表达式间有多少空白符并不重要，程序使用 *缩进* 显示代码结构是代码尽可能易读
*Comments* may appear on any line of a Scheme program, between a semicolon(;) a
nd the end of the line.
*注释* 可以出现在任意行使用分号(;)包含.
Comments explaining a particular Scheme expresssion are normally palacd at the 
same indentation level as expresion, on the line before the expression.
注释一个表达式，通常在表达式上一行并和表达式保持同一缩进级别，
Comments explaining a procedure or group of prececdures are normally placed bef
ore the precedures, without identation.
注释一个过程，通常在过程的上面并没有缩进格式。
Multiple comment characters are often used to set offf the latter kind of comme
nt, e.g., ;;; The following precedures ...
使用多个注释符(;;;)来注释多个过程
Two other forms of comments *are supported*: block comments and datum comments.
支持另外两种形式的注视： *块注释* 和 *资料(数据)注释*
*Block comments are delimited by #| and |# pairs, and may be nested.*
块注释使用 *#| ... |#* 分割，并且可嵌套。
A *datum comment* consists of a *#;* prefix and the datum(printed data value) t
hat follows it. Datum comments are typically used to comment out individual def
initions or expressions. For example, *(three #;(not four) element list)* is ju
st what is says.
*资料(数据)注释* 有 *#;* 作为前缀跟随 *数据值* 用于注视单个定义或表达式。
Datum comments may also *be nested*, though #;#;(a)(b) has the somewhat nonobvi
ous effect of commenting out both (a) and (b).
*数据注释* 可以被嵌套
Some Scheme values, such as procedure and ports, do not have standard printed r
epresentations and can thus never appear as constant in the printed syntax of a
 program. The book uses the notation #<description> when showing the output of 
an operation that returns such a value, e.g., #<procedure> or #<port>.
一些 *Sehcme值(如过程、端口)* 不能通过标准打印表现，不能以常理形式打印程序语法，
本书采用 *#<描述>* 的方式显示即 *#<precedure> #<port>*
*** Second study
Scheme programs are made up of *keywords*, *variables*, *structured forms*, 
*constant data* (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), 
*whitespace*, and *comments*.

**** Identifiers (keywords, variables, symbols)
Keywords, variables, and symbols are collectively called identifiers.
关键字、变量和符号统称为标识符。

Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, <, =, >, :, $, %, ^, &, _, ~, and @, as well as a set of additional Unicode characters. 
标识符可以由字母、数字和某些特殊字符组成，包括?、!、。、+、-、*、/、<、=、>、:、$、%、^、&、_、~和@，以及一组额外的Unicode字符。

Identifiers cannot start with an at sign ( @ ) and normally cannot start with any character that can start a number, i.e., a digit, plus sign ( + ), minus sign ( - ), or decimal point ( . ). 
标识符不能以@开头，通常也不能以任何以数字开头的字符开头，例如，数字、加号(+)、减号(-)或小数点(.)．

Exceptions are +, -, and ..., which are valid identifiers, and any identifier starting with ->. 
例外情况是+、-和…，是有效的标识符，以及任何以->开头的标识符。

For example, hi, Hello, n, x, x3, x+2, and ?$&*!!! are all identifiers.
例如，hi, Hello, n, x, x3, x+2，和?$&*!!都是标识符。

Identifiers are delimited by whitespace, comments, parentheses, brackets, string (double) quotes ( " ), and hash marks( # ).
标识符由空格、注释、圆括号、方括号、字符串(双)引号(")和散列标记(#)分隔。

A delimiter or any other Unicode character may be included anywhere within the name of an identifier as an escape of the form \xsv;, where sv is the scalar value of the character in hexadecimal notation.
分隔符或任何其他Unicode字符可以包含在标识符名称的任何位置，作为形式\ sv;的转义，其中sv是该字符在十六进制表示法中的标量值。

There is no inherent limit on the length of a Scheme identifier; 
Scheme标识符的长度没有固有的限制;

Identifiers may be written in any mix of upper- and lower-case letters, and case is significant, i.e., two identifiers are different even if they differ only in case. 
标识符可以是大小写字母的任意组合，大小写是重要的，也就是说，两个标识符即使只在大小写上不同，也是不同的。
abcde, Abcde, AbCdE, and ABCDE all refer to different identifiers. *大小写敏感*
**** *Structured forms* and *list constants* are enclosed within parentheses
结构化表单和列表常量用圆括号括起来

The empty list is written ().

Matched sets of brackets ( [ ] ) may be used in place of parentheses and are often used to set off the subexpressions of certain standard syntactic forms for readability
匹配的括号集合([])可以用来代替圆括号，通常用于衬托某些标准语法形式的子表达式，以提高可读性
**** *Vectors* are written similarly to lists, except that they are preceded by #( and terminated by ), e.g., #(this is a vector of symbols). 
vector的写法类似于list，除了它们前面有#(并以#结尾)，例如，e.g., #(this is a vector of symbols). 
**** *Bytevectors* are written as sequences of unsigned byte values (exact integers in the range 0 through 255) bracketed by #vu8( and ), e.g., #vu8(3 250 45 73).
字节向量被写成无符号字节值序列(0到255之间的精确整数)，用#vu8(和)括起来，例如，#vu8(3 250 45 73)。
**** *Strings* are enclosed in double quotation marks e.g., "I am a string"
**** *Characters* are preceded by #\, e.g., #\a.
**** *Numbers* may be written as integers, e.g., -123, as ratios, e.g., 1/2, 
in floating-point or scientific notation, e.g., 1.3 or 1e23, 
or as complex numbers in rectangular or polar notation, e.g., 1.3-2.7i or -1.2@73. 
*Case is not important* in the syntax of a number
**** The *boolean* values representing true and false are written #t and #f. 
Scheme conditional expressions *actually treat #f as false* and all other objects as true, so 3, 0, (), "false", and nil all count as true.
**** Details of the syntax for each type of *constant data* are given in the individual section
每种类型的常量数据的语法细节在第6章的各个小节中给出，Scheme的正式语法从第455页开始。
**** Scheme *expressions* may span several lines, and no explicit terminator is required. 
方案表达式可以跨几行，不需要显式的结束符。

Since the number of whitespace characters (spaces and newlines) between expressions is not significant, Scheme programs should be indented to show the structure of the code in a way that makes the code as readable as possible.
因为表达式之间的空白字符(空格和换行符)的数量并不重要，所以Scheme程序应该缩进以显示代码结构，使代码尽可能具有可读性。
**** *Comments* may appear on any line of a Scheme program, between a semicolon ( ; ) and the end of the line. 
Comments explaining a procedure or group of procedures are normally placed before the procedures, without indentation.

Comments explaining a procedure or group of procedures are normally placed before the procedures, without indentation
解释一个过程或一组过程的注释通常放在过程之前，没有缩进
Multiple comment characters are often used to set off the latter kind of comment, e.g., ;;; The following procedures ....
后面的注释通常使用多个注释字符

Two other forms of comments are supported:
支持另外两种形式的注释, 块评论和数据评论
- Block comments are delimited by #| and |# pairs, and may be nested.
- A datum comment consists of a #; prefix and the datum (printed data value) that follows it.
  Datum comments are typically used to comment out individual definitions or expressions. 
  数据注释通常用于注释掉单独的定义或表达式
  For example, (three #;(not four) element list)
**** Some Scheme values, such as procedures and ports
do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. 
This book uses the notation #<description> when showing the output of an operation that returns such a value, e.g., #<procedure> or #<port>.
一些Scheme值，比如过程和端口，没有标准的打印表示，因此永远不会在程序的打印语法中作为常量出现。本书在显示返回这样一个值的操作的输出时使用了#<描述>符号，例如，#<过程>或#<端口>。

** 2.Scheme Naming Conventions(Scheme 命名约定)
   Scheme's naming conventions *are designed* to provide a high dagree of regul
arity. The following is a list of these nameing conventions.
*Scheme的命名约定* 被设计成提供高度规则性。 以下列出了命名约定。
- Predicate names end in a question mark(?). Predicates are procedures that ret
  urn a true or false answer, such as eq?,zero?,string?. The common numeric com
  parators =,<,>,<=,>= *are excetions* to this name conversion.
  *谓词* 使用问号(?)结尾。 *谓词是一个返回真假值得过程*
- *Type predicates* such as pair?, *are created* from the name of type, in this
  case pair, and the questiong mark.
  *类型谓词* 使用类型名后缀?表示，如： 是否为pair类型， *pair?*
- The names of procedures that convert an object of one type into an object of 
  another type are-written as type->type2,e.g., *vector->list*.
  过程转化一个对象到另一个对象使用 类型1->类型2。
- The names of precedures and syntactic forms that *cause side effacts* end wit
  h an exclamation point(!).
  对产生副作用的过程和语法形式使用感叹号(!)结尾。
Programmers should employ these same conventions in their own code whenever pos
sible.
程序员任何时候必须在他们的代码中准守以上约定。
** 3.Typographical and Notational Conventions(字体排版与符号预订)
A standard procedure or syntactic form whose sole purpose is to perform some si
de effect is-said to return unspecified.
一个标准过程或句法形式唯一目的是产生返回未知名的一些副作用。(获取结果)
This means that an implementation is free to return any number of values, each 
of which can be any Scheme object, as the value of the procedure or syntactic f
orm.
这意味着一个过程或句法的实现可以返回任意多个值，每个值可以是任意的Scheme对象。
Do not count on these values being the same across implementations, the same ac
ross versions of the same implementation, or even the same across two uses of t
he procedure or syntaticform.
_不要期望这些值在实现上是一样的，相同版本甚至相同的过程或句法。_
Some Scheme systems routinely(常规地) use a special object to represent unspeci
fied values.
通常一些Scheme系统使用特定对象表示未指定的值。
Printing of this object is often suppressed by interactive Scheme systems, so t
hat the values of expressions retuning unspecified values are not printed.
一些交互式Scheme系统抑制打印这些对象，因此表达式返回未知的值不被打印。
While most standard procedures return a single value, the language supports pro
cedure that returns zero, one, more then one, or even a variable number of valu
es via the mechanisms described in Section 5.8.
多数过程放回一个值，语言支持返回0，1，>1 甚至一个可变数量的值(5.8节)。
Some standard expressoins can evaluate to multiple values if one of their subex
pressions evaluates to multiple values,e.g., by calling a procedure that return
s multiple values.
标准表达式可以对多值进程求值，如果他们的子表达式通过调用一个返回多值的过程计算出
多值。
When this situation can occur, an expression is said to return "the values" rath
er than simply "the value" of its subexpression.
但返回多值的情况发生，说放回多个值比返回一个值更合理。
Similary, a standard procedure that returns the values resulting from a call to
 a procedure arguments is said to return the values returnd by the precedure ar
gument.
类似地，一个标准过程从调用一个过程参数返回的值表达成过程参数返回的值。
This book uses the words "must" and "should" to describe program requirements, 
such as the requirement to provide an index that is less then the length of the
 vector in al call to vector-ref. If the word "must" is used, it means that the
 requirement is enforced by the implementation, i.e., an exceptions is raised, 
usually with condition type &assertion. If the word "should" is used, an except
ion may or may not be raised, and if not, the behavior of the program is undefi
ned.
本书使用"必须"和"应该"去表述程序需求，违反使用"必须"的条件见返回异常。违反使用
"应该"的情况可能会产生异常也可能不产生异常但程序结果是未定义的(不可预测的)。

The phrase *syntax violation* *is used* to describe a situation in which a prog
ram *is malformed*. Syntax violation *are deteched prior to* program execution.
When a syntax violation is-deteced, an exception of type &syntax is-raised and 
program is not executed.
*语法错误* 被用来表示程序格式错误的情况。语法错误在程序执行前被检查。但语法错误
被检测到，将产生&syntax类型的异常，程序不被执行。

The typographical conventions used in this book are-straightforward. All Scheme
objects are-printed in a *typewriter typeface打字机字体*, just as they are to b
e typed at the keyboard. This include syntactic keywords, variables, constant o
bjects, Scheme expressions, and example programs. An italic typeface is-used to
set off syntax variables in the descriptions of syntactic forms and arguments i
n the descriptions of procedures. Italics are also used to set off technical te
rms the first time they appear.
本书的印刷约定是简洁的。所有Scheme对象都使用打字机字体，就如同他们从键盘输入的一
样。Scheme 对象包括 *关键字、变量、常量对象、表达式和示例程序* 。 *斜体字* 用于
指出 *句法变量 和 过程参数*, 也用于 *第一次出现的技术术语*。

In general, names of syntactic forms and procedures are never *capitalized大写*
even at the beginning of a sentence. The same is true for syntax varialble writ
ten in italics.
通常句法和过程的名字不会大写，即使是在句首。同样适用于语法变量使用斜体字的形式。

In the description of a syntactic form or procedure, one or more prototype patt
erns show the syntactic form or forms or the correct number of numbers of argum
ents for an application of the procedure.
在描述一个句法形式或一个过程，一个或多个原型样式显示句法形式、形式或应用过程的正
确参数。
The keyword or procedure name is-given in typewrite font, as are-parentheses.
*关键字、过程名、圆括号使用打印机字体*
The remaining pieces of the syntax or arguments are show in italics, using a na
me that implies the type of expression or argument expected by the syntactic fo
rm or procedure.
*其余部分 使用斜体字* 使用名字指出 *表达式类型* 或 *句法、过程的参数*
*Ellipses* are-used to specify *zero or more occurrences* of a subexpression or
arguments. For example, (=or= /expr/ ...) describes the or syntatic form, which 
has zero or more subexpressions, and (=member= /obj/ /list/)describes the member 
procedure, which expects two arugments, an object and a list.
*省略号* 用于指定保护 *0个或多个(不定参数)* 的子表达式或参数。例如(or expr ...)
=or= 句法形式含有0个或多个子表达式。(=member= /obj/ /list/)表示 =member= 过程包
含2个参数，其中一个对象参数和一个列表参数。
A *syntax violation* occors if the structure of a syntactic form not match its 
*prototype*.
如果句法形式不匹配 *句法原型声明* 将发生 *语法错误*。
Similarly, an exception with condition type =&assertion= is-raised if the numbe
r of arguments passed to a standard procedure does not match what it is specifi
ed to receive.
同样，如果一个标准过程的参数传递不匹配他的指定接受类型将抛出 =&assertion= 类型
异常。
A exception with condition type =&assertion= is also raised if a standard proce
dure receives an augument whose type is not the type implied by its name or doe
s not meet other *criteria标准* given in the description of the procedure. For 
example, the prototype for =vector-set!= is =(vector-set /vector/ /n/ /obj/)=
and the description says that =/n/= must be an *exact精确的* nonnegative intege
r *strictly严格的* less than the length of =/vector/=. Thus, =vector-set!= must
recevie three arguments, the first of which must be a vector, the second of whi
ch must be a exact nonnegative integer less than the length of the vector, and 
the third of which may be any Scheme value. Otherwise, an exception with condit
ion type =&assertion= is-raised.
如果一个标准过程接受到不是参数名称指定的类型或符合表述的其他标准，也将抛出异常。
例如句法原型 =(vector-set! /vector/ /n/ /obj/)= 表述了 =/n/= 是精确的非负整数严
格的小于 =vector= 长度，第三个参数是任意的Scheme对象，否则引起断言异常。
In most cases, the type of argument required is *obvious明显的*, as with vector
, =/obj/=, or =/binary-input-port/=.
大部分情况下，参数类型是明显的，如 =/vector,obj,binrary-input-port/= 。
In others, primarily within the descriptions of numeric routines, abbreviations
areused, such as =/int/= for integer, =/exint/= for exact integer, and =/fx/= f
or fixnum. These abbreviations are-explained at the start of the section contai
ning the effected entries.
另外，主要的数值类型使用 *缩写* 形式表示。 *int* 指整数， *exint* 指精确的整数
*fx* 指固定大小的数。 这些缩写在本节开头已经有解释。
* 2. Getting Started(开始)
TODO: now
  This chapter is an introduction to Scheme for programmers who are new to he l
anguage. You will get more from this chapter if you are sitting in front of an 
interactive Scheme system, trying out the examples as you go.
本章正对Scheme新手进行介绍，如果你使用交互式Scheme系统进行训练效果将会效果更好。
After reading this chapter and working the exercise, you should be able to star
t using Scheme. You will have learned the syntax of Scheme program and how they
are-executed, along with how to use simple data structures and control mechanis
ms.
通过阅读本章和完成练习，将掌握如何使用Scheme。将学到Scheme程序语法，其如何被执
行，使用数据结构和控制机制。
** 1.Interacting with Scheme(和Scheme进行交互)
*** 1.交互式环境
   Most Scheme system provide an interactive programming enviroment that simpli
fies program development and experimentation.
大多数Scheme系统提供交互编程环境，这样简化了程序的开发和实验。

The simplest interaction with Scheme follows a "read-evaluate-print" cycle. A p
rogram(often called a read-evaluate-print loop, or REPL) reads each expression 
you type at the keyboard, evaluates it, and prints its value.
最简单的Scheme交互遵循 读-求值-打印 循环。 一个REPL程序读取键盘输入的表达式，对
其进行求值然后把值打印出来。

With an interactive Scheme system, you can type an expression at the keyboard a
nd see its value immediately.
通过Scheme交互系统，可以键盘输入表达式并立刻看到表达式的值。

You can define a procedure and apply it to arguments to see how it works.
可以定义一个过程，用相应的参数调用他，观察其如何工作的。

You can even type in an entire program consisting of a set of procedure definit
ions and test it without leaving the system.
在不断开交互系统前提下，可以编写并测试一个由一系列相关联的过程组成的程序。

When you program starts getting longer, it will be more convenient to type it i
nto a file(using a text editor), load the file and test it interactively.
当程序变得越来越大时，将程序写到文件里面去，并加载文件进行交互式
的测试是一个非常便利的做法。

In most Scheme system, a file may be-loaded with the nonstandard procedure load
, which takes a string argument naming the file.
大多数Scheme系统，使用一个非标准过程 =(load "/file/")= 来加载文件。

Preparing you program in a file has several advantages: you have a chance to co
mpose you program more carefully, you can correct errors without retyping the p
rogram, and you can retain a copy for later use. Most Scheme implementations tr
eat expressions loaded from a file the same as expressoins typed at the keyboar
d.
使用文件来保持程序是非常有利的：
*有机会精心组织程序*
*修改错误是不需要重新打印程序*
*保留一份副本供以后使用*
大多数Scheme实现一致的方式对待 *从文件导入* 和 *键盘输入* 的表达式。

While Scheme provides various input and output procedures, the REPL takes care 
of reading expressions and printing their values. This frees you to concentrate
on writing your program without worrying about how its results will be display
ed.
Scheme 提供多样的输入输出过程， REPL 细心的读取表达式并打印其值。这解放了结果如
何显示的细节思考，专注于编写程序。
*** 2.(表达式)=>表达式输出值
    The examples in this chapter and in the rest of the book follow a regular f
ormat. An expression you might type from your keyboard is-given first, possibly
spanning several lines. The value of expression is-given after the *=>*, to be- 
read as "evaluates to." The => is-omitted for definitions and when the value of
an expression is-unspecified.
本书的示例代码遵循正规格式。一个表达式，可能跨越多行。其值打印在 *=>* 后面，读
作"求值得到"。当未为定义时将 *省略 is-omitted* =>。
*** 3.美观的代码格式
The example programs are-formatted in a style that "looks nice" and conveys the
struct of the program.
示例以"美观"的格式展示程序结构。
The code is easy to read because the relationship between each expression and i
ts subexpressions is clearly shown.
由于表达式和子表达式间清晰地显示结构使得代码阅读非常容易。
Scheme ignores indentation and line breaks, however, so there is no need to fol
low a particular sytle.
Scheme 忽略缩进和换行，然后，他不需要遵守特定的格式。
The important thing is to establish one style and keep to it. Scheme sees each 
programs as if it were on a single line, with its subexpressions ordered from l
eft to right.
只保持一条重要的规则，Scheme对待每个程序为单行代码，以从左到右的顺序排列子表达
式。
*** 4.常量表达式示例
    If you have access to an interactive Scheme system, it might be a good idea
to start it up now and type in the examples as you read.
如果你打开了Scheme交互系统，一个好的主意是现在开始输入每一个你读到的示例代码。
One of the simplest Scheme expressions is a *string constant*.
最简单的表达式是 *字符常量string-constant*.
Try typing "Hi Mom!"(including the double quotes) in response to the prompt.
试着在 *提示符prompt* 后输入"Hi Mom"(包含双引号)。
The system should respond with "Hi Mom!"; the value of any constant is constant
itself.  "Hi Mon" => "Hi Mon"
系统将应答"Hi Mom!"; *常量的值是常量自身*

"hello" => "hello"
42 => 42
22/7 => 22/7
3.141592653 => 3.141592653
+ => #<procedure +>
(+ 76 31) => 107
(* -12 10) => -120
'(a b c d) => (a b c d)

Be careful not to miss any single quotes('), double quotes("), or pharentheses.
*注意不要遗漏任何单引号('),双引号("),圆括号*
If you left off a single quote in the last expression, you probaly received a m
essage indicating that an exception has occurred.
如果你丢了最后那个表达式的单引号，将收到一个异常消息。
Just try again. If you left off a closing parentheses or double quote, the syst
em might still be waiting for it.
在尝试一次，如果你遗漏由圆括号或双引号，系统将继续等待输入。

There are a few more expressions to try. You can try to figure out on your own 
what they mean or wait to find out later in the chapter.
这里是更多表达式，可以指出其含义或者在本章的后续找出其含义。
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cons 'a '(b c)) => (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)

As you can see, Scheme expressions may span more then one line. The Scheme know
s when it has a entire expression by matching double quotes and parentheses.
如上Scheme表达式可以跨越多行。Scheme通过配对双引号和圆括号来识别出完整的表达式。
*** 5.定义过程(defining a procedure)
    Next, let's try defining a procedure.
    接下来，让我们尝试定义一个过程。
#+BEGIN_SRC scheme
;; square(n)
(define square
  (lambda (n)
    (* n n)))
#+END_SRC
The procedure =square= computes the square n^2 of any number n. We say more abo
ut the expressions that make up this deifnitions later in this chapter.
这个过程计算了n的平方。我们将在本章的后面更多地讲解这个表达式组成。
For now it suffices to say that =define= establishes variable bindings =lambda=
creates procedures, and =*= names the multiplicatoin procedure.
当前将 =define= 理解为建立变量绑定， =lambda= 理解为创建过程， =*= 表示乘法过程
就 *足够suffices* 了。
Note the form of these expressions.
记住这些表达式的形式。
All structured forms *are-enclosed in parentheses* and written in *prefix notation*
i.e., the operator precedes the arugments.
所有形式的构造都 *被一对圆括号包围* ，并且采用 *前序标记法* 即操作在参数前面。
As you can see, this is true even for simple arithmetic orprations such as *.
如你所见，乘法操作数也是如此，采用前序标记法。
Try using square.

(square 5) => 25
(square -200) => 40000
(square 0.5) => 0.25
(square -1/2) => 1/4

Even through the next definition is short, you might enter it into a file. Let'
s assume you call the file "reciprocal.ss".
让我们定义一个叫倒数的过程，保存到 "reciprocal.ss" 文件中，虽然有代码点短。
#+BEGIN_SRC scheme
(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))
#+END_SRC
This procedure, =reciprocal=, computes the quantity 1/n for any number n!=0. Fo
r n = 0, =reciprocal= returns the string "oops!". Return to Scheme and try load
ing your file with procedure =load=.
=reciprocal= 这个过程当n不等于0时对n求倒数，当n等于0时返回"oops!"字符串。保存文
件后，使用 =load= 加载这个过程。
Finally, try using the procedure we have just defined.

(reciprocal 10) => 1/10
(reciprocal 1/10) => 10
(reciprocal 0) => "oops!"
(reciprocal (reciprocal 1/10)) => 1/10

In the next section we will discuss Scheme expressions in more detail.
在下一节我们将更详细的讨论表达式。
Throughout this chapter, keep in mand that your Scheme system is one of the mos
t useful tools for learning Scheme.
请记住Scheme交互系统是最有效的学习Scheme编程的方式。
Whenever you try one of the examples in the text, follow it up with your own ex
amples. In an interactive Scheme system, the cost of trying something out is re
latively small--usually just the time to type it in.
每当尝试一个示例，非常的便捷，仅仅需要打印一下的时间 。
** 2.Simple Expressions(简单的表达式)
   The simplest Scheme expression are *constant data objects*, such as strings,
numbers, symbols, and list.
最简单的Scheme表达式是 *数据对象常量* 例如：字符串，数值，符号，列表。
Scheme supports other object types, but thess for are enough for many programs.
Scheme 支持其他的对象类型，但上面的四类对象已经满足很多程序的需求。
We saw some examples of strings and numbers in preceding section.
我们在前面一节已经看到了一些字符串和数值的示例。
*** 1.讨论数值细节(discuss numbers in a little more detail)
    Let's discuss numbers in a little more detail. Number are *constants*. If y
ou enter a number, Scheme echos it back to you. The following examples show tha
t Scheme supports several types of numbers.
123456789987654321 => 123456789987654321
3/4 => 3/4
2.718281828 => 2.718281828
2.2+1.1i => 2.2+1.1i
让我们在详细一点的讨论数值。数值是一个常数。如果输入一个数值，Scheme将回射这个数
。下面的示例显示了Scheme支持多种数据类型。

Scheme numbers include *exact integer* and *inexact integer*, *rational*, *real*
*complex numbers*.
Scheme数值包含 *精确整数* *不精确整数* *有理数* *实数* *复数*
Exact integers and retional numbers have arbitrary precision, i.e., they can be 
arbitrary size.
精确整数和有理数具有 *任意的精度*, 即其大小是任意的。
Inexatc numbers are usually represented internally using IEEE standard floating
-point representations.
非精确数值通常使用IEEE标准的浮点数表示。
*** 2.数学运算符过程(arithmetic procedures)
    Scheme provides the names *+ - * /* for corresponding arithmetic procedures
Each procedure accepts two numeric arguments.
Scheme 提供 *+ - * /* 为相应的数学运算过程。每个运算符接受2个参数。

The expressions below are-called *precedure applications*, because the specify 
the application of a procedure to a set of arugments.
(+ 1/2 1/2) <graphic> 1
(- 1.5 1/2) <graphic> 1.0 

(* 3 1/2) <graphic> 3/2
(/ 1.5 3/4) <graphic> 2.0
一下表达式被称为 *过程应用程序* ，因为应用程序指定了一个参数集合到了一个过程。
Scheme employs prefix notation even for common arithmetic operations.
*** 3.前序标记法
Scheme 对数学运算符同样采用 *前序标记法* 。
Any procedure application, whether the procedure taske zero, one or two, or mor
e arugments, is-written as =(procedure /arg/ ...)=.
任何过程应用程序，不论其包含 0，1，2，... 个参数都写成 =(procedure /arg/ ...)=
This regularity simplifies the syntax of expressions;
*前序标记法* 规则简化了表达式的语法；
one notation is-employed regardless of the operation, and there are no complica
ted rules regarding the precedence or assiciativity of operators.
*前序标记法* 是的任意的操作只遵循一个标准，没有复杂的运算符优先级和结合性问题。
*** 4.过程嵌套(Procedure applications may be-nested)
    Procedure applications may be-nested, in which chase the innermost values a
re computed first. We can thus nest applications of the arithmetic procedure gi
ven above to evalute more complicated formulas.
(+ (+ 2 2) (+ 2 2)) => 8
(- 2 (* 4 1/3)) => 2/3
(* 2 (* 2 (* 2 (* 2 2)))) => 32
(/ (* 6/7 7/2) (- 4.5 1.5)) => 1.0

过程可以被嵌套，当需要 *内部值innermost* 先被计算时。我们可以嵌套算数过程来计算
更 *复杂的公式complicated formulas* 。

These examples demonstrate everything you need to use Scheme as a four-function
desk calculator.
上面这些示例演示了使用Scheme实现一个 *四则运算* 的桌面计算器。
While we will not discuss them in this chapter, Scheme supports many other arit
hmatic preocdures.
本章我们不讨论Scheme支持的其他算数运算过程。
Now might be a good time to turn to Section 6.4 and experiment with some of them.
现在可能是一个好时机，跳到6.4节去实验他们。

*** 5.聚合数据结构(aggregate data structures)
    Simple numeric objects are sufficient for many tasks, but sometimes aggrega
te data structures containing two or more values are-needed.
简单数值通常是满足一些任务的需求，但有时需要包含两个及以上值得 *数据结构* 。
*** 6.列表(数据聚合的基础)
In many languages, the basic aggregate data structure is the array. In Scheme, 
it is the *list*.
在多少语言中数组是聚合数据结构的基础，但在Scheme中 *list* 是聚合数据的基础。
List are-written as sequences of objects surrounded by parentheses. For instanc
e, (1 2 3 4 5) is a list of numbers, and ("this" "is" "a" "list") is a list of 
string.
*列表* 在书写时被一对圆括号包含，如(1 2 3 4 5)是数值列表，("this" "is" "a" "list")
是一个字符串列表。
List need not contain only one type of object, so (4.2 "hi") is a valid list co
ntaining a number and a string.
*列表* 不局限于包含一类对象。
Lists may be nested (may contain other list), so ((1 2) (3 4))is a valid list w
ith two elements, each of which is a list of two elements.
*列表* 可以 *嵌套*
*** 7.单引号运算符(' 明确指定为列表)
    You might notice that list looks just like procedure applications and wonde
r how Scheme tell them apart. That is, how does Scheme distinguish between a li
st of objects =(/obj1/ /obj2/ ...)= and a procedure application 
=(proc /arg/ ...)=
你也许发现了列表和过程非常相似，并向知道Scheme如何区分列表和过程。
In some cases, the distinction might seem obvious. The list of numbers (1 2 3)
could hardly be-confused with a procedure application, since 1 is a number, no
t a procedure.
一些情况下，区别是明显的。列表(1 2 3)很难和过程混淆，因为1是数值不是过程。
So, the answer might be that Scheme looks at the first element of the list or
procedure application and makes its decision based on whether that firt element
is a procedure or not.
因此，一个可能的答案是看第一项是否为过程。
This answer is not good enough, since we might even want to treat a valid proce
dure application such as (+ 3 4) as a list.
这个答案并不足够好，因为有时我们想将一个过程视作一个列表，如(+ 3 4)。
The answer is that we must tell Scheme explicitly to treat a list as data rathe
r than as a procedure application. *We do this with quote*

(quote (1 2 3 4 5)) => (1 2 3 4 5)
(quote ("this" "is" "a" "list")) => ("this" "is" "a" "list")
(quote (+ 3 4)) => (+ 3 4)

正确答案是我们通过 *前缀单引号的方式来明确告示Scheme将过程视作列表* 。

The =quote= forces the list to be-treated as data. Try entering the above expre
ssions without the quote; you will likely receive a message indicating that an 
excetpions has occurrd for the first two and an incorrent answer(7) for the thi
rd.
=quote= 强制列表视作数据。试着不带quote输入以上表达式，你将收到一个消息指出前两
个表达式一次和第三个表达式返回一个不完整的答案7。

Because =quote= is-required firly frequently in Scheme code, Scheme recognizes 
a single quotion mark (') precedding an expression as an abbreviation for quote
#+BEGIN_SRC scheme
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
#+END_SRC
应为 =quote= 使用非常频繁，为了方便Scheme使用缩写的单引号 ' 前缀到表达式上。
Both forms are-refered to as quote expressions. We often say an object is-quote
d when it is enclose in a quote expression.
=(quote (1 2 3))= 和 '(1 2 3) 是等价的表达式。当单引号包含一个表达式时通常称对象
被引用。
A quote expression is /not/ a procedure application, since is *inhibits(阻止)* 
the evaluation of its subexpression. It is a entirely different syntactic form.
引用表达式不是过程，应为阻止了其子表达式被求值。这是一个完全不同的句法。
Scheme supports several other syntactic forms in addition to preocedure applica
tions and quote expressions.
除quote句法外，Scheme 还支持另外几种句法。
Eache syntactic form is-evaluated differently. Fortunately, the number of diffr
rent syntactic is small. We will see more of them in this chapter.
每种句法都有不同的求值方式。幸运的是句法不多，我们将在本周看到大部分。
*** 8.符号与变量(symbol and variable)
Not all quote expressions involve lists. Try the following expression with and 
without the quote wrapper.
(quote hello) => hello
不是所有引用表达式都包含列表。
The *symbol* hello must be-quoted in orde to *prevent防止* Scheme from treating
hello as a /variable/.
符号hello必须被引用，为了防止hello被当作变量。
Symbols and variables in Scheme are similar to symbols and viarables in mathema
tical expressions and equations.
Scheme的符号和变量类似于数学表达式和方程式的符号和变量。
When we evaluate the mathmatical expression 1 - x for some value of x, we think
of x as a *variable*.
当我们使用x的一些值求值一个数学表达式(1 - x)时，我们把x想象成变量。
On the other hand, wend we consider the *algebraic equation* x^2 - 1 = (x-1)(x+
1), we think of x as a *symbol* (in fact, we tink of the whole equation symboli
cally).
另一方面，我们认为代数方程式是一个符号。
Just as quoting a list tells Scheme to treat a parenthesized form as a list rah
her than as a procedure applicatoin, quoting an identifire tell Scheme to treat
the identifier as a symbol than as a variable.
就如同引用一个列表告知Scheme将括号内的形式视作列表而不是过程，引用一个标识符告
诉Scheme将标识符作为符号而不是变量。
While symbols are commonly used to represent variables in symbolic representati
ions of equations or program, symbols may also be-used, for example, as words i
n the representation of natural language sentence.
在方程式或程序中，符号通常被表示为变量，如在自然语言中符号表示成单词。
*** 9.程序也是数据(同质特性)
You might wonder why applicatons and variables shared notations with list and s
ymbols.
你可能想知道为什么程序和变量都使用同一种标记法，列表和符号。
The shared notation allows Scheme programs to be-represented as Scheme data, si
plifying the writing of interpreters, compilers, editors, and other tools in Sc
heme.
*共享标记法使得Scheme程序可视作Scheme数据，这样简化了解释器，编译器，编辑器和*
*其他Scheme工具的开发*
This is-demonstrated by the Scheme interpreter given in Scetion 12.7, which is 
itself written in Scheme. Many people believe this is to be one of the most im
portant features of Scheme.
使用Scheme语言编写Scheme语言的解释器，很多人相信这是Scheme语言的重要特性。
*** 10.数据、字符串的引用就是自身
    Numbers and strings may be quoted, too.
'1 => 1
'2/3 => 2/3
(quote "Hi Mom!") => "Hi Mom!"
Number and string are-treated as constants in any case, however, so quoting the
m is unnecessary.
在任何情况下数值和字符串被当作常来，因此不需要进行引用操作。
*** 11.列表操作过程(procedures for manipulating lists)
    Now let's discuss some Scheme proecedure for manipulating lists. There are 
two basic procedure for taking lists apart: =car= and =cdr= (pronouced could-er
). =car= return the first element of a list, and =cdr= returns the remainder of
the list.(The names car and cdr are-derived from operations supported by the fi
rst computer on which a Lisp language was-implemented, the IPM 704.)Each requir
es a nonempty list as its arguments.
现在让我们讨论一些列表操作相关的过程。有两个基本过程，car 获取列表的第一项，cdr
获取列表的后续项。car和cdr都需要一个非空列表作为其参数
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cdr '(a)) => () 

(car (cdr '(a b c))) => b
(cdr (cdr '(a b c))) => (c) 

(car '((a b) (c d))) => (a b)
(cdr '((a b) (c d))) => ((c d))

(cons 'a '()) => (a)
(cons 'a '(b c)) => (a b c)
(cons 'a (cons 'b (cons 'c '()))) => (a b c)
(cons '(a b) '(c d)) => ((a b) c d) 

(car (cons 'a '(b c))) => a
(cdr (cons 'a '(b c))) => (b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)
(cons (car '(a b c))
      (cdr '(a b c))) => (a b c)

*proper list(常规列表)*
(a b)
[a,-]->[b,()]
*improper/dotted list(非常规/点列表)*
(a . b)
[a,b]

** 3. Evaluating Scheme Expressions(表达式求值)
   Let's turn to a discussion of how Scheme evaluates the expressions you type.
下面我们讨论Scheme是如何求值表达式。 
We have already established the rules for constant objects such as strings and 
numbers: the object itself is the value.
我们已经建立了对象构造规则，如字符串和数值对象本身就是表达式值。
You have probably also worked out in your mind a rule for evaluating applicatio
ns of the form =(procedure arg1 ... argn)= .
你可能在自己的脑海中已经算出 =(procedure arg1 ... argn)= 的求值过程。
Here, /porcedure/ is an expression representing a Scheme procedure, and arg1 ..
argn are expressions representing its arugments. One possiblity is the following
*(quote expressons) 引用表达式不求值*
Constant objects, preocedure applications, quote expressions are only three of 
many syntactic forms provided by Scheme.
*常量、过程、引用 三类核心句法， 外还有少数其他句法根据核心句法扩展的*
*扩展句法 (let ((key value) ...)) (lambda (arg...) body...)*
1. 从左向右求值
2. 过程变量求值方式和过程求值一样
(car '(+ - * /) 2 3) => Exception: attempt to apply non-procedure +
(car (+ - * /) 2 3) => Exception in +: #<procedure -> is not a number
*(car (list + - * /) 2 3) => 5*
** 4.Variables and Let Expressions
*(let ((var expr)...) body1 body2 ...)*
*let* 句法实现了 一个 *值* *绑定* 一个 *变量*
优点：避免相同表达式的重复写于计算。
  (+ (* 4 4) (* 4 4)) => 32
  (let ((a (* 4 4))) (+ a a)) => 32
*[] 可以替代 () 方便阅读*
[let [[x 2]] [+ 2 x]] => 4
*变量作用域在let表达式内*
*(let ...) 可嵌套定义*
*如有同名变量，内存变量则掩盖外层变量，使得外表变量不可见*
(let ([x 1])
  (let ([x (+ x 1)])
    (+ x x))) => 4
外部x *scope作用域* 外部括号 减去 内部括号；
*lexical scope词法作用域*
** 5. Lambda Expressions (lambda 表达式)(简单理解为匿名过程)
lambda 解决了 let 表达式的局限；
((lambda (x) (+ x x)) 3) ==> 6
(let ([x 3]) (+ x x))

let/lambda 混合应用

(let ([x 'a])
  (let ([f (lambda (y) (list x y))])
    (f 'b))) => (a b)
x 相对于 lambda 是自由变量， *自由变量必须已绑定* ；
y 相对于 lambda 不是自由变量；

*(let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)*
*let 是由 lambda 扩展的*

(let ([f (lambda x x)])
  (f 1 2 3 4)) => (1 2 3 4) 

(let ([f (lambda x x)])
  (f)) => () 

*lambda (x . y) y 表示所有剩余的参数, 类似C的 fn(args ...)*
(let ([g (lambda (x . y) (list x y))])
  (g 1 2 3 4)) => (1 (2 3 4)) 

(let ([h (lambda (x y . z) (list x y z))])
  (h 'a 'b 'c 'd)) => (a b (c d))

> (let ([f (lambda (x) x)])
  (f 'a))
a
> (let ([f (lambda x x)])
  (f 'a))
(a)
> (let ([f (lambda (x . y) x)])
  (f 'a))
a
> (let ([f (lambda (x . y) y)])
  (f 'a))
()
> 
How might the primitive procedure list be-defined?
** 6. Top-Level Definitions(顶层定义/全局定义)
   let, lambda 表达式绑定的变量对外不可见。
   顶层定义(全局可见，除了被内部定义覆盖外)
   *define* 创建一个顶层定义对象
   #+BEGIN_SRC scheme
   (define double-any
     (lambda (f x)
       (f x x)))
   #+END_SRC
** 2.9 Assignment(分派)
   #+BEGIN_SRC scheme
   ;; 全局变量
   (define abcde '(a b c d e))
   (set! abcde (cdr abcde))
   ;; 局部作用域覆盖全局作用域
   (let ([abcde '(a b c d e)])
     (set! abcde (reverse abcde))
     abcde)
   ;; 变量不需要声明，可直接使用
   ;; 请平方根 (-b(+/-)(b^2 - 4ac))/2a
   (define quadratic-formula
     (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
         (set! minusb (- 0 b))
         (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
         (set! divisor (* 2 a))
         (set! root1 (/ (+ minusb radical) divisor))
         (set! root2 (/ (- minusb radical) divisor))
         (cons root1 root2))))
   ;; without assignment
   (define quadratic-formula
     (lambda (a b c)
       (let ([minusb (- 0 b)]
             [radical (sqrt (- (* b b) (* 4 (* a c))))]
             [divisor (* 2 a)])
         (let ([root1 (/ (+ minusb radical) divisor)]
               [root2 (/ (- minusb radical) divisor)])
           (cons root1 root2)))))
   ;; let 只读；let! 可读写

   ;; 本地状态缓存
   (define lzay
     (lambda (t)
       (let ([val #f] [flag #f])
         (lambda ()
           (if (not flag)
               (begin (set! val (t))
                      (set! flag #t)))
           val))))
   #+END_SRC
* 3. Going Further(进阶)
** 3.1 Syntatic Extension(语法扩展)
   核心句法
   (define ...)
   constans
   varialbes
   procedure application
   quote expressions
   lambda expressions
   if expressions
   set! expressions

<program>	<graphic>	<form>*
<form>	<graphic>	<definition> | <expression>
<definition>	<graphic>	<variable definition> | (begin <definition>*)
<variable definition>	<graphic>	(define <variable> <expression>)
<expression>	<graphic>	<constant>
|	<variable>
|	(quote <datum>)
|	(lambda <formals> <expression> <expression>*)
|	(if <expression> <expression> <expression>)
|	(set! <variable> <expression>)
|	<application>
<constant>	<graphic>	<boolean> | <number> | <character> | <string>
<formals>	<graphic>	<variable>
|	(<variable>*)
|	(<variable> <variable>* . <variable>)
<application>	<graphic>	(<expression> <expression>*)

(begin e1 e2 ...) == ((lambda () e1 e2 ...))

(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]))
   扩展句法

** 3.2 More Recursion(更多递归)
** 3.3 Continuations(连续性)
   - call/cc ; 捕获任意表达式的的continuation
   - (call/cc p) ; 以procedure为唯一参数
   - (call/cc (lambda (k) ...)) ; k 表示 continuation, continuation 是procedure
   - 在 p 内部调用 (k v)，则p返回v，否则返回p的结果
   - k 在 (call/cc p) 所在表达式的位置，作为continuation，外部调用(k v)
     时，(call/cc p)作为值v代，继续求值表达式。
   #+BEGIN_SRC scheme
   (call/cc
    (lambda (k)
      (* 5 4))) ;=> 20 = p
   (call/cc
    (lambda (k)
      (* 5 (k 4)))) ;=> 4 = p

   (define kon #f)
   (define kon1 #f)
   (cons 1
    (list (call/cc
           (lambda (k)
             (set! kon1 k)
             k))
          (call/cc
           (lambda (k)
             (set! kon k)
             (k 3)
             4)))) ;=> (1 #<continuation> 3)

   ;; (cons 1 (list con1 3))
   ;; (cons 1 (list 5 3))
   ;; (cons 1 '(5 3))
   ;; (1 5 3)
   (kon1 5) ;=> (1 5 3)
   (kon1 6) ;=> (1 6 3)
   (kon 4)  ;=> (1 6 4)

   (kon1 (lambda (x)
           (+ 1 x))) ;=> (1 #<procedure> 3)
   (define call/kon1
     (lambda (x)
       (kon1 ((lambda (x1)
                (+ x1 x))
              2))))
   ;;; (1 #<procedure> 3)
   (call/kon1 4) ;=> (1 6 3)
   ;;; <=>
   (cons 1
         (list ((lambda (x)
                  ((lambda (x1)
                     (+ x1 x)) 2))4)
               3)) ; => (1 6 3)

   ;; define con4 被bingding为continuation
   ;; define con4 #<continuation>
   (define kon4
     (call/cc
      (lambda (k) k)))
   kon4 ;=> #<continuation>
   (list 1 kon4 3) ;=>(1 #<continuation> 3)
   ;; 调用kon4 在define处被重新binding 为 5
   (kon4 5) ;** (define con4 5) 
   kon4 ;=> 5
   (list 1 kon4 3) ;=> (1 5 3)
   ;; 由kon4被重新binding为5，不再时continuation
   ;; (5 6) 抛出异常
   (kon4 6) ; Exception: attempt to apply non-procedure 5

   (let ([x (call/cc (lambda (k) k))])
     (x (lambda (ignore) "hi")))
   ;; <=>
   (let ([x (lambda (ignore) (display ignore))])
     (x (lambda (ignore) (display ignore))))

   ;; 递归情况下的后续
   (define retry1 #f)
   (define factorial
     (lambda (x)
       (if (= x 0)
           (call/cc (lambda (k) (set! retry1 k) 1))
           (* x (factorial (- x 1))))))
   (trace factorial)
   (trace retry1) ;=> Exception in trace: the top-level value of retry1 is not a procedure
   (factorial 4)
   #|
   (factorial 4)
   |(factorial 4)
   | (factorial 3)
   | |(factorial 2)
   | | (factorial 1)
   | | |(factorial 0)
   | | |1
   | | 1
   | |2
   | 6
   |24
   24
   |#
   retry1 ;=> #<system continuation>
   (trace retry1) ;=> (retry1)
   ;; trace 使 retry1 状态由 continuation 变为 procedure
   retry1 ;=> #<procedure>

   (retry1 2)
   #|
   |(retry1 2)
   | | |2
   | | 2
   | |4
   | 12
   |48
   48
   |#
   (retry1 3)
   #+END_SRC

*** 3.3.1 light-weight process(lwp 轻量进程)
    - nonpreemptive 非抢占
    - pause -> continue
    #+BEGIN_SRC scheme
    ;;; 非抢占多任务系统

    ;;; 任务队列
    (define lwp-list '())
    ;;; 插入任务
    (define lwp
      (lambda (trunk)
        (set! lwp-list (append lwp-list (list trunk)))))
    ;;; 执行一个任务
    (define start
      (lambda ()
        ;; 取出头部任务
        (let ([p (car lwp-list)])
          ;; 将头部任务从链表移除
          (set! lwp-list (cdr lwp-list))
          ;; 执行任务
          (p))))

    ;; 让出执行权，调度其他任务
    (define pause
      (lambda ()
        (call/cc
         (lambda (k)
           (lwp (lambda () (k #f)))
           (start)))))

    (define trunk
      (lambda (p x)
        (lambda ()
          (let f ([cur-cnt 1] [max-cnt 20])
            ;; 控制循环次数，防止无限循环
            (when (<= cur-cnt max-cnt)
                  (pause)
                  (p x)
                  (f (+ 1 cur-cnt) max-cnt))))))

    (lwp (trunk display "h"))
    (lwp (trunk display "e"))
    (lwp (trunk display "y"))
    (lwp (trunk display "!"))
    (lwp (trunk display "\n"))
    (trace start lwp pause)
    (start)
    #+END_SRC
*** Exercise 3.3.1
    #+BEGIN_SRC scheme
    ;; 0
    ;; 1
    ;; 2 ... 100 ...
    (let ([k.n (call/cc (lambda (k) (cons k 0)))])
      (let [[k (car k.n)] [n (cdr k.n)]]
        (write n)
        (newline)
        (k (cons k (+ n 1)))))

    (call-with-values
        (lambda () (call/cc (lambda (k) (values k 0))))
      (lambda (k n)
        (write n) (newline)
        (k k (+ n 1))))

    (define product
      (lambda (ls)
        (if (null? ls)
            1
            (if (= (car ls) 0)
                0
                (let ([n (product (cdr ls))])
                  (if (= n 0) 0 (* n (car ls))))))))
    (trace product)
    (product '(1 2 3 4))
    #+END_SRC
** 3.4 Continuation Pass Style(连续传输方式)
   隐式后继转显式后继
   #+BEGIN_SRC scheme
   (letrec ([f (lambda (x) (cons 'a x))]
            [g (lambda (x) (cons 'b (f x)))]
            [h (lambda (x) (g (cons 'c x)))])
     (cons 'd (h '()))) ;=> (d b a c)

   (letrec ([f (lambda (x k) (k (cons 'a x)))]
            [g (lambda (x k)
                 (f x (lambda (v) (k (cons 'b v)))))]
            [h (lambda (x k) (g (cons 'c x) k))])
     (h '() (lambda (v) (cons 'd v))))
   ;;;  x   k
   (g (cons 'c '()) (lambda (v) (cons 'd v)))
   ;;; f x             k
   (f (lambda (k x) (k (cons 'a x))))
   (lambda (cons 'a (cons 'c '())))
   ;;;
   (letrec ([h (lambda (x k) (cons x (k 'a)))]
            [g (lambda (y) (cons 'c y))])
     (h 'b g))
   (letrec ([h (lambda (x) (cons x 'a))]
            [g (lambda (y) (cons y (h 'b)))])
     (g 'c))

   (eval '(cons 3 4))
   `(+ 2 3 ,(* 3 4))
   `(a b ,(reverse '(c d e)) f g)
   (let ([a 1]
         [b 2])
     `(,a . ,b))

   `(+ ,(cdr '(* 2 3)))
   `(+ ,@(cdr '(* 2 3)))
   #+END_SRC
** 3.5 Internal Definitions(内部定义)
** 3.6 Libraries(库)
* 5. Control Operations
** 5.3.Conditionals
*** syntax: (if test consequent alternative) 
    syntax: (if test consequent) 
    returns: the values of consequent or alternative depending on the value of test 
    libraries: (rnrs base), (rnrs)
    
    test consequent alternative,都是过程
    #+BEGIN_SRC c
    if(test){
            consequent;
    }else{
            auternative;
    }
    #+END_SRC
    
    #+BEGIN_SRC scheme
    (if #t
        'true
        'false)
    (if #f
        'true
        'false)
    (if #f
        'true
        'flase
        'invalid-stax)
    (if #f
        (begin
          'true1
          'true2)
        (begin
          'false1
          'false2))
    (if #f
        'true) ;; no return value
    #+END_SRC
*** syntax: (cond clause1 clause2 ...) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
    syntax: else  ;; auxiliary keywords
    syntax: =>    ;; auxiliary keywords
    libraries: (rnrs base), (rnrs exceptions), (rnrs)
    - clause
      (test) ;; return the first not #f value
      (test expr1 expr2 ...) ;; return last expr values
      (test => expr) ;; return (expr test)
    - last cause
      clause
      (else expr1 expr2 ...) ;; none true, return last expr values
    - 流程
      直到测试为真的clause返回，或最后一条else;
    - example
      #+BEGIN_SRC scheme
      (let ([x 0])
        (cond
          [(< x 0) (list 'minus (abs x))]
          [(> x 0) (list 'plus x)]
          [else (list 'zero x)])) ;; (zero 0) 

      (define select
        (lambda (x)
          (cond
            [(not (symbol? x))]
            [(assq x '((a . 1) (b . 2) (c . 3))) => cdr]
            [else 0]))) 

      (select 3) ;; #t
      (select 'b) ;; 2
      (select 'e) ;; 0
      #+END_SRC
   
*** syntax: (when test-expr expr1 expr2 ...)
    等价于 (if #t (begin expr1 expr2 ...))
    #+BEGIN_SRC scheme
    (define-syntax when
      (syntax-rules ()
        [(_ e0 e1 e2 ...)
         (if e0 (begin e1 e2 ...))]))

    (let ([x 10] [y 0])
      (when (> x 0)
            (set! y (+ x y))
            (set! x (- x 1))
            (display x) (newline)))
    #+END_SRC
*** syntax: (unless test-expr expr1 expr2 ...)
    <==> (if #f (begin expr1 expr2 ...))
    #+BEGIN_SRC scheme
    (define-syntax unless
      (syntax-rules ()
        [(_e0 e1 e2 ...)
         (when (not e0) e1 e2 ...)]))
    #+END_SRC
*** syntax: (case expr0 clause1 caluse2 ...)
    #+BEGIN_SRC scheme
    (let ([x 4] [y 5])
      (case (+ x y)
        [(1 3 5 7 9) 'odd]
        [(2 4 6 8 0) 'even]
        [else 'out-of-range]))

    ;;; test symbol
    (define test-symbol-case
      (lambda (x)
        (case x
          ;; not support symbol list
          ['(aaa bbb) (printf "aaa or bbb~%")]
          [(list 'aaa 'bbb) (printf "list aaa,bbb~%")]
          ;; single symbol ok
          ['hello (display "hello\n")]
          [else (display "else\n")])))
    (test-symbol-case 'aaa)
    (test-symbol-case 'bbb)
    (test-symbol-case 'hello)
    (test-symbol-case 'ccc)
    #+END_SRC
** 5.4.Recursion and Iteration
*** syntax: (let name ((var expr) ...) body1 body2 ...) 
    returns: values of the final body expression 
    libraries: (rnrs base), (rnrs)

    命名let,是一个通用的迭代和递归构造。
    <name>自身绑定到<let lambda>，参数列表被重新绑定到<var ...>
    
    #+BEGIN_SRC scheme
    ;;; 寻找除数
    (define divisors
      (lambda (n)
        (let f ([i 2])
          (cond
            [(>= i n) '()]
            [(integer? (/ n i)) (cons i (f (+ i 1)))]
            [else (f (+ i 1))])))) 

    (divisors 5) ;; ()
    (divisors 32) ;; (2 4 8 16)

    ;;; int j = 0;
    ;;; for(int i=0; i < 10; ++i){
    ;;;   j += i;
    ;;; }
    (let ([j 0])
      (let sum-j ([i 0])
        (if (< i 10)
            (begin
              (set! j (+ j i))
              (sum-j (+ i 1)))))
      j)
    #+END_SRC
*** syntax: (do ((var init update) ...) (test result ...) expr ...)
    returns: the values of the last result expression 
    libraries: (rnrs control), (rnrs)
    
    - description
      do允许简洁地表达一种常见的限制形式的迭代。
      变量var ...最初绑定到init ...的值，并在每次后续迭代时重新绑定到update ...的值。
      如果test的值为true，则迭代停止，表达式result ...按顺序计算，并返回最后一个表达式的值。
      如果test的值为false，则按顺序计算表达式expr ...，计算表达式update ...，创建var ...的新绑定到update ...的值，并继续迭代。
    #+BEGIN_SRC scheme
    ;;; int j = 0;
    ;;; for(i = 0; i <= 10; ++i){
    ;;;   j += i
    ;;; }
    (let ([j 0])
      (do ((i 0 (+ i 1)))
          ((> i 10) j)
        (set! j (+ j i))))

    ;;; 将j作为do的迭代变量；
    (define sum-all
      (lambda (n)
        (do ([i 10 (- i 1)] [j 0 (+ j i)])
            ((zero? i) j))))
    (sum-all 10)
    #+END_SRC
    
* 6. Operations on Objects(对象的操作)
  本章描述对象支持的操作，对象包括：
  list,numbers,characters,strings,vectors,bytevectors,symbols,booleans,
  hashtables,enumerations.
** 6.1 Constants and Quotation(常量和引用)
   [[file:../src/tspl-6-Operations-on-Objects/6.1-Constants-and-Quotation.ss]]

*** 常量
    syntax: constant 
    returns: constant
    
*** 引用
    syntax: (quote obj) 
    syntax: 'obj 
    returns: obj 
    libraries: (rnrs base), (rnrs)

    引用阻止了对象的求值，使对象作为数据。
    常量的引用时自身，所以常量不需要进行引用。
    引用、常量时不变的，不能通过set-car!,string-set!来操作，否则抛出异常
    
**** syntax: (quasiquote obj ...) 
     准引用
     syntax: `obj
     
     反引用，准引用中的内容进行求值，后拼接
     syntax: (unquote obj ...)
     syntax: ,obj 
     
     作用将列表/向量内容提取出来，拼接
     syntax: (unquote-splicing obj ...) 
     syntax: ,@obj 

     但它允许引用文本的部分内容“进行求值”
     unquote和unquote-splicing仅在quasiquote表达式中有效。
     #+BEGIN_SRC scheme
     `(+ 2 3) ;=> (+ 2 3)
     ;;; 反引用对(* 3 4)进行求值然后拼接
     `(+ 2 ,(* 3 4)) ;=>(+ 2 12)
     ;;; 反引用可以是变量
     (let ([a 1] [b 2])
       `(,a . ,b)) ;=> (1 . 2)

     ;;; ,@(...) 链表提取拼接
     `(+ 2 ,(list 3 4)) ;=> (+ 2 (3 4))
     `(+ 2 ,@(list 3 4)) ;=> (+ 2 3 4)

     `(1 ,@2) ;=> (1 . 2)
     `(,@2) ;=> 2
     `(,2) ;=> (2)

     `(a (unquote (+ 3 3) (* 3 3)) b)
     `(a ,(+ 3 3) ,(* 3 3) b)

     (let ([x '(m n)])
       ``(a ,@,@x f))
     (let ([x '(m n)])
       (eval `(let ([m '(b c)]
                    [n '(d e)])
                `(a ,@,@x f))
             (environment '(rnrs))))
     #+END_SRC
** 6.2.Generic Equivalence and Type Predicates
   [[file:../src/tspl-6-Operations-on-Objects/6.2-Generic-Equivalnce-and-Type-Precidcates.ss]]

   谓词：返回#t或#f的过程
   
*** procedure: (eq? obj1 obj2) 
    returns: #t if obj1 and obj2 are identical, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    eq? obj1,obj2指向的指针相同返回#t,否则#f。
    - 两个不同类型的对象（布尔值，空列表，对，数字，字符，字符串，向量，符号和过程）是不同的。
    - 具有不同内容或值的两个相同类型的对象是不同的。
    - 布尔对象#t无论出现在哪里都与自身相同，并且#f在任何地方都与自身相同，但#t和#f是不同的。
    - 空列表（）在其出现的任何地方都是相同的。
    - 当且仅当它们具有相同的名称时，两个符号是相同的（通过string =？）。
    - 不能用于可靠地比较数字和字符。
    
    #+BEGIN_SRC scheme
    ;;; 不同类型间比较
    (eq? 'a 3) ;=> #f
    (eq? #t 't) ;=> #f
    (eq? "abc" '(abc)) ;=> #f
    (eq? "abc" 'abc) ;=> #f
    (eq? #f '()) ;=> #f
    ;;; 同类型不同值比较
    (eq? 9/2 7/2) ;=> #f
    (eq? 3.4 2342) ;=> #f
    (eq? 3 3.0) ;=> #f
    (eqv? 3 3.0) ;=> #f
    (eq? 1/3 #i1/3) ;=> #f
    (eqv? 1/3 #i1/3) ;=> #f
    ;;; 同类型同值比较
    (eq? 9/2 9/2) ;=> #f
    (eqv? 9/2 9/2) ;=> #t
    (eq? 'hello 'hello) ;=> #t
    (let ([x (* 22222222222222 322222222222222222222)])
      (eq? x x)) ;=> #t
    ;;; #t,#f 始终相等
    (eq? (null? '()) #t) ;=> #t
    (eq? (null? '(a)) #f) ;=> #t
    ;;; null始终相等
    (eq? (cdr '(a)) '()) ;=> #t
    ;;; 同名符号始终相等
    (eq? 'abc (string->symbol "abc")) ;=> #t

    (eq? '(a) '(a)) ;=> #f 内存指针不同
    (eqv? '(a) '(a)) ;=> #t
    (equal? '(a) '(a)) ;=> #t
    #+END_SRC
*** procedure: (eqv? obj1 obj2) 
    returns: #t if obj1 and obj2 are equivalent, #f otherwise 
    libraries: (rnrs base), (rnrs)

    eqv? obj1,obj2 值相等且除eq?,eqv?外不能区分不等；
    
    
*** procedure: (equal? obj1 obj2) 
    returns: #t if obj1 and obj2 have the same structure and contents, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    
*** procedure: (boolean? obj) 
    returns: #t if obj is either #t or #f, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    (lambda (x) (or (eq? x #t) (eq? x #f)))

*** procedure: (null? obj) 
    returns: #t if obj is the empty list, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    (lambda (x) (eq? x '()))

*** procedure: (pair? obj) 
    returns: #t if obj is a pair, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
*** procedure: (number? obj)
    returns: #t if obj is a number object, #f otherwise 
    procedure: (complex? obj) 
    returns: #t if obj is a complex number object, #f otherwise 
    procedure: (real? obj) 
    returns: #t if obj is a real number object, #f otherwise 
    procedure: (rational? obj) 
    returns: #t if obj is a rational number object, #f otherwise 
    procedure: (integer? obj) 
    returns: #t if obj is an integer object, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (real-valued? obj) 
    returns: #t if obj is a real number, #f otherwise 
    procedure: (rational-valued? obj) 
    returns: #t if obj is a rational number, #f otherwise 
    procedure: (integer-valued? obj) 
    returns: #t if obj is an integer, #f otherwise 
    libraries: (rnrs base), (rnrs)

    虚部为0.0i时 同real?,rational?,integer?

*** procedure: (char? obj) 
    returns: #t if obj is a character, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (string? obj) 
    returns: #t if obj is a string, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (vector? obj) 
    returns: #t if obj is a vector, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (symbol? obj) 
    returns: #t if obj is a symbol, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (procedure? obj) 
    returns: #t if obj is a procedure, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (bytevector? obj) 
    returns: #t if obj is a bytevector, #f otherwise 
    libraries: (rnrs bytevectors), (rnrs)

*** procedure: (hashtable? obj)
    returns: #t if obj is a hashtable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)
** 6.3.List and Pairs
   pair(cons cell) 基本结构对象。
   [ car . cdr ]-->[last-element . ()]
      |     |                       \- 常规列表(),非常规列表可以时任意对象
      |     \- linked one to the next
      \- element
*** 构造形态
**** 构造二叉树
                [ptr.ptr]
                 /    \
               car   cdr
**** 常规链表
    [car . cdr]-->[car . cdr]-->...-->[car.()]
**** 非常规链表
    [car . cdr]

    (1 2 3 . 4)
    [1.*]-->[2.*]-->[3.4]

    ((1.2).3)
       [*.3]
       /
    [1.2]

    (1 . (2 . (3 . ())))
    (1 2 3)
    [1.*]-->[2.*]-->[3.()]
**** 环形链表
    set-car!,set-cdr!来改变car，cdr实现环形链表
    [1.*]-->[2.*]-->[3.*]->+
       \---<---------------+
*** procedure: (cons obj1 obj2) 
    returns: a new pair whose car and cdr are obj1 and obj2 
    libraries: (rnrs base), (rnrs)
*** procedure: (car pair) 
    returns: the car of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (cdr pair) 
    returns: the cdr of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (set-car! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (set-car! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (set-cdr! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (caar pair) 
    procedure: (cadr pair)
    procedure: (cddddr pair) 
    returns: the caar, cadr, ..., or cddddr of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (list obj ...) 
    returns: a list of obj ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (cons* obj ... final-obj) 
    returns: a list of obj ... terminated by final-obj 
    libraries: (rnrs lists), (rnrs)
*** procedure: (list? obj) 
    returns: #t if obj is a proper list, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (length list) 
    returns: the number of elements in list 
    libraries: (rnrs base), (rnrs)
*** procedure: (length list) 
    returns: the number of elements in list 
    libraries: (rnrs base), (rnrs)
*** procedure: (list-ref list n) 
    returns: the nth element (zero-based) of list 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define list-ref
      (lambda (ls n)
        (if (= n 0)
            (car ls)
            (list-ref (cdr ls) (- n 1))))) 
    #+END_SRC
*** procedure: (list-tail list n) 
    returns: the nth tail (zero-based) of list 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define list-tail
      (lambda (ls n)
        (if (= n 0)
            ls
            (list-tail (cdr ls) (- n 1))))) 
    #+END_SRC
*** procedure: (append) 
    procedure: (append list ... obj) 
    returns: the concatenation of the input lists 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define append
      (lambda args
        (let f ([ls '()] [args args])
          (if (null? args)
              ls
              (let g ([ls ls])
                (if (null? ls)
                    (f (car args) (cdr args))
                    (cons (car ls) (g (cdr ls)))))))))
    #+END_SRC
*** procedure: (reverse list) 
    returns: a new list containing the elements of list in reverse order 
    libraries: (rnrs base), (rnrs)
    
    #+BEGIN_SRC scheme
    (define reverse
      (lambda (ls)
        (let rev ([ls ls] [new '()])
          (if (null? ls)
              new
              (rev (cdr ls) (cons (car ls) new)))))) 
    #+END_SRC
*** procedure: (memq obj list) 
    eq? member
    procedure: (memv obj list) 
    eqv? member
    procedure: (member obj list) 
    equal? member
    returns: the first tail of lwist hose car is equivalent to obj, or #f 
    libraries: (rnrs lists), (rnrs)

    #+BEGIN_SRC scheme
    (define memq
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eq? (car ls) x) ls]
          [else (memq x (cdr ls))])))
    #+END_SRC
*** (memp procedure list) 
    returns: the first tail of list for whose car procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (remq obj list) 
    procedure: (remv obj list) 
    procedure: (remove obj list) 
    returns: a list containing the elements of list with all occurrences of obj removed 
    libraries: (rnrs lists), (rnrs)
*** procedure: (remp procedure list) 
    returns: a list of the elements of list for which procedure returns #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (filter procedure list) 
    returns: a list of the elements of list for which procedure returns true 
    libraries: (rnrs lists), (rnrs)
*** procedure: (partition procedure list) 
    returns: see below 返回多值 = 2list，#t + #f
    libraries: (rnrs lists), (rnrs)
*** procedure: (find procedure list) 
    returns: the first element of list for which procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (assq obj alist) 
    procedure: (assv obj alist) 
    procedure: (assoc obj alist) 
    returns: first element of alwist hose car is equivalent to obj, or #f 
    libraries: (rnrs lists), (rnrs)
    #+BEGIN_SRC scheme
    (define assq
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eq? (caar ls) x) (car ls)]
          [else (assq x (cdr ls))])))
    #+END_SRC
*** procedure: (assp procedure alist) 
    returns: first element of alist for whose car procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (list-sort predicate list) 
    returns: a list containing the elements of list sorted according to predicate 
    libraries: (rnrs sorting), (rnrs)
    

** 6.4.Numbers
   分类为整数，有理数，实数或复数。
   因为所有整数都是理性的，所有有理数都是实数，所有实数都是复数。
   也可以归类为精确或不精确,exact? inexact?
   Scheme中对数字的大多数操作都是精确保留：如果给定精确操作数，它们返回精确值，
   如果给出不精确的操作数或精确和不精确操作数的组合，则返回不精确的值。
   精确整数和有理算术通常支持任意精度;
   
   3+4i, 3.2-3/4i, +i
   1.1@1.764 and -1@-1/2 

   +inf.0 and -inf.0 正/负无穷大
   +nan.0/-nan.0 非数值

   - #e,#i 强制数字精确性
   - 默认10进制，#b(binary),#o(otcal),#d(decimal),#x(hexadecimal)
   - 但是系统打印机（由put-datum，write和display调用）和number-> string以紧凑的形式表示数字，
*** procedure: (exact? num) 
    returns: #t if num is exact, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (inexact? num) 
    returns: #t if num is inexact,e #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (= num1 num2 num3 ...) 
    procedure: (< real1 real2 real3 ...) 
    procedure: (> real1 real2 real3 ...) 
    procedure: (<= real1 real2 real3 ...) 
    procedure: (>= real1 real2 real3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (+ num ...) 
    returns: the sum of the arguments num ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (- num) 
    returns: the additive inverse of num 
    procedure: (- num1 num2 num3 ...) 
    returns: the difference between num1 and the sum of num2 num3 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (* num ...) 
    returns: the product of the arguments num ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (/ num) 
    returns: the multiplicative inverse of num 
    procedure: (/ num1 num2 num3 ...) 
    returns: the result of dividing num1 by the product of num2 num3 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (zero? num) 
    returns: #t if num is zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (positive? real) 
    returns: #t if real is greater than zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (negative? real) 
    returns: #t if real is less than zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (even? int) 
    returns: #t if int is even, #f otherwise
*** procedure: (odd? int) 
    returns: #t if int is odd, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (finite? real) 
    returns: #t if real is finite, #f otherwise 
*** procedure: (infinite? real) 
    returns: #t if real is infinite, #f otherwise 
*** procedure: (nan? real) 
    returns: #t if real is a NaN, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (quotient int1 int2) 
    returns: the integer quotient of int1 and int2 
    procedure: (remainder int1 int2) 
    returns: the integer remainder of int1 and int2 
    procedure: (modulo int1 int2) 
    returns: the integer modulus of int1 and int2 
    libraries: (rnrs r5rs)
*** procedure: (div x1 x2) 
    procedure: (mod x1 x2) 
    procedure: (div-and-mod x1 x2) 
    returns: see below 
*** procedure: (div0 x1 x2) 
    procedure: (mod0 x1 x2) 
    procedure: (div0-and-mod0 x1 x2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (truncate real) 
    returns: the integer closest to real toward zero 
    libraries: (rnrs base), (rnrs)
*** procedure: (floor real) 
    returns: the integer closest to real toward -inf.0
    libraries: (rnrs base), (rnrs)
*** procedure: (ceiling real) 
    returns: the integer closest to real toward +inf.0
    libraries: (rnrs base), (rnrs)
*** procedure: (round real) 
    returns: the integer closest to real 
    libraries: (rnrs base), (rnrs)
*** procedure: (abs real) 
    returns: the absolute value of real 
    libraries: (rnrs base), (rnrs)
*** procedure: (max real1 real2 ...) 
    returns: the maximum of real1 real2 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (min real1 real2 ...) 
    returns: the minimum of real1 real2 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (gcd int ...) 
    returns: the greatest common divisor of its arguments int ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (lcm int ...) 
    returns: the least common multiple of its arguments int ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (expt num1 num2) 
    returns: num1 raised to the num2 power 
    libraries: (rnrs base), (rnrs)
*** procedure: (inexact num) 
    returns: an inexact representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact num) 
    returns: an exact representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact->inexact num) 
    (为兼容Revised5)
    returns: an inexact representation of num 
    procedure: (inexact->exact num) 
    returns: an exact representation of num 
    libraries: (rnrs r5rs)
*** procedure: (rationalize real1 real2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (numerator rat) 
    returns: the numerator of rat 
    libraries: (rnrs base), (rnrs)
*** procedure: (denominator rat) 
    returns: the denominator of rat 
    libraries: (rnrs base), (rnrs)
*** procedure: (real-part num) 
    returns: the real component of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (imag-part num) 
    returns: the imaginary component of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-rectangular real1 real2) 
    returns: a complex number with real component real1 and imaginary component real2 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-polar real1 real2) 
    returns: a complex number with magnitude real1 and angle real2 
    libraries: (rnrs base), (rnrs)
*** procedure: (angle num) 
    returns: the angle part of the polar representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (magnitude num) 
    returns: the magnitude of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (sqrt num) 
    returns: the principal square root of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact-integer-sqrt n) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (exp num) 
    returns: e to the num power 
    libraries: (rnrs base), (rnrs)
*** procedure: (log num) 
    returns: the natural logarithm of num 
    procedure: (log num1 num2) 
    returns: the base-num2 logarithm of num1 
    libraries: (rnrs base), (rnrs)
*** procedure: (sin num) 
    procedure: (cos num) 
    procedure: (tan num) 
    returns: the sine, cosine, or tangent of num 
    libraries: (rnrs base), (rnrs)
    procedure: (asin num) 
    procedure: (acos num) 
    returns: the arc sine or the arc cosine of num 
    libraries: (rnrs base), (rnrs)
    procedure: (atan num) 
    procedure: (atan real1 real2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (bitwise-not exint) 
    returns: the bitwise not of exint 
    procedure: (bitwise-and exint ...) 
    returns: the bitwise and of exint ... 
    procedure: (bitwise-ior exint ...) 
    returns: the bitwise inclusive or of exint ... 
    procedure: (bitwise-xor exint ...) 
    returns: the bitwise exclusive or of exint ... 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-if exint1 exint2 exint3) 
    returns: the bitwise "if" of its arguments 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-bit-count exint) 
    returns: see below 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-length exint) 
    returns: see below 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-first-bit-set exint) 
    returns: the index of the least significant bit set in exint 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    ...

    #+BEGIN_SRC scheme
    (define bitwise-if
      (lambda (exint1 exint2 exint3)
        (bitwise-ior
          (bitwise-and exint1 exint2)
          (bitwise-and (bitwise-not exint1) exint3))))
    #+END_SRC
*** procedure: (string->number string) 
    procedure: (string->number string radix) 
    returns: the number represented by string, or #f 
    libraries: (rnrs base), (rnrs)
    procedure: (number->string num) 
    procedure: (number->string num radix) 
    procedure: (number->string num radix precision) 
    returns: an external representation of num as a string 
    libraries: (rnrs base), (rnrs)
** 6.5.Fixnums
   Fixnums表示fixnum范围内的精确整数，它必须是一个闭合范围[-2w-1,2w-1 - 1]，其中w（fixnum宽度）至少为24.
*** procedure: (fixnum? obj) 
    returns: #t if obj is a fixnum, #f otherwise
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (least-fixnum) 
    returns: the least (most negative) fixnum supported by the implementation 
*** procedure: (greatest-fixnum) 
    returns: the greatest (most positive) fixnum supported by the implementation 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fixnum-width) 
    returns: the implementation-dependent fixnum width 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx=? fx1 fx2 fx3 ...) 
    procedure: (fx<? fx1 fx2 fx3 ...) 
    procedure: (fx>? fx1 fx2 fx3 ...) 
    procedure: (fx<=? fx1 fx2 fx3 ...) 
    procedure: (fx>=? fx1 fx2 fx3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxzero? fx) 
    returns: #t if fx is zero, #f otherwise 
    procedure: (fxpositive? fx) 
    returns: #t if fx is greater than zero, #f otherwise 
    procedure: (fxnegative? fx) 
    returns: #t if fx is less than zero, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxeven? fx) 
    returns: #t if fx is even, #f otherwise 
    procedure: (fxodd? fx) 
    returns: #t if fx is odd, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxmin fx1 fx2 ...) 
    returns: the minimum of fx1 fx2 ... 
    procedure: (fxmax fx1 fx2 ...) 
    returns: the maximum of fx1 fx2 ...
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx+ fx1 fx2) 
    returns: the sum of fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx- fx) 
    returns: the additive inverse of fx 
    procedure: (fx- fx1 fx2) 
    returns: the difference between fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx* fx1 fx2) 
    returns: the product of fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxdiv fx1 fx2) 
    procedure: (fxmod fx1 fx2) 
    procedure: (fxdiv-and-mod fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxdiv0 fx1 fx2) 
    procedure: (fxmod0 fx1 fx2) 
    procedure: (fxdiv0-and-mod0 fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx+/carry fx1 fx2 fx3) 
    procedure: (fx-/carry fx1 fx2 fx3) 
    procedure: (fx*/carry fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxnot fx) 
    returns: the bitwise not of fx 
    procedure: (fxand fx ...) 
    returns: the bitwise and of fx ... 
    procedure: (fxior fx ...) 
    returns: the bitwise inclusive or of fx ... 
    procedure: (fxxor fx ...) 
    returns: the bitwise exclusive or of fx ... 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxif fx1 fx2 fx3) 
    returns: the bitwise "if" of its arguments 
    libraries: (rnrs arithmetic fixnums), (rnrs)
    #+BEGIN_SRC scheme
    (define fxif
      (lambda (fx1 fx2 fx3)
        (fxior (fxand fx1 fx2)
               (fxand (fxnot fx1) fx3))))
    #+END_SRC
*** procedure: (fxbit-count fx) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxlength fx) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxfirst-bit-set fx) 
    returns: the index of the least significant bit set in fx 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxbit-set? fx1 fx2) 
    returns: #t if bit fx2 of fx1 is set, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxcopy-bit fx1 fx2 fx3) 
    returns: fx1 with bit fx2 replaced by fx3 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxbit-field fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxcopy-bit-field fx1 fx2 fx3 fx4) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxarithmetic-shift-right fx1 fx2) 
    returns: fx1 arithmetically shifted right by fx2 bits 
    procedure: (fxarithmetic-shift-left fx1 fx2) 
    returns: fx1 shifted left by fx2 bits 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxarithmetic-shift fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxrotate-bit-field fx1 fx2 fx3 fx4) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxreverse-bit-field fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)

** 6.6.Flonums

*** procedure: (flonum? obj) 
    returns: #t if obj is a flonum, otherwise #f 
    libraries: (rnrs arithmetic flonums), (rnrs)

*** procedure: (fl=? fl1 fl2 fl3 ...) 
    procedure: (fl<? fl1 fl2 fl3 ...) 
    procedure: (fl>? fl1 fl2 fl3 ...) 
    procedure: (fl<=? fl1 fl2 fl3 ...) 
    procedure: (fl>=? fl1 fl2 fl3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs arithmetic flonums), (rnrs)
*** MORE procedures
    ...
** 6.7.Characters
   字符是表示字母，数字，特殊符号（如$或 - ）和某些非图形控制字符（如空格和换行符）的原子对象。
   字符使用＃\前缀编写。 #\a #\b
   字符换行符，空格和制表符也可以这种方式编写，但它们可以更清晰地编写为＃\ newline，＃\ space和＃\ tab。
   任何Unicode字符都可以用＃\ xn语法编写，
*** procedure: (char=? char1 char2 char3 ...) 
    procedure: (char<? char1 char2 char3 ...) 
    procedure: (char>? char1 char2 char3 ...) 
    procedure: (char<=? char1 char2 char3 ...) 
    procedure: (char>=? char1 char2 char3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (char->integer char) 
    returns: the Unicode scalar value of char as an exact integer 
    libraries: (rnrs base), (rnrs)

    (char->integer #\newline) ;; 10
    (char->integer #\space) ;; 32
    (- (char->integer #\Z) (char->integer #\A)) ;; 25
    
    procedure: (integer->char n) 
    returns: the character corresponding to the Unicode scalar value n 
    libraries: (rnrs base), (rnrs)
    
    n must be an exact integer and a valid Unicode scalar value, i.e., ;; or ;;.

    (integer->char 48) ;; #\0
    (integer->char #x3BB) ;; #\;;
** 6.8.Strings
   字符串是字符序列，通常用作消息，字符缓冲区或文本块的容器。
   Scheme提供了创建字符串，从字符串中提取字符，获取子字符串，连接字符串以及更改字符串内容的操作。
   字符串包含在双引号中，"this is string"
   字符串中包含双引号的话，内部的双引号采用 \"; "this is string include \" double quotes \""
   可以使用其他双字符序列插入各种特殊字符，例如\ n表示换行符，\ r表示回车符，\ t表示制表符。 "line1\nline2"
*** procedure: (string=? string1 string2 string3 ...) 
    procedure: (string<? string1 string2 string3 ...) 
    procedure: (string>? string1 string2 string3 ...) 
    procedure: (string<=? string1 string2 string3 ...) 
    procedure: (string>=? string1 string2 string3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-ci=? string1 string2 string3 ...) 
    procedure: (string-ci<? string1 string2 string3 ...) 
    procedure: (string-ci>? string1 string2 string3 ...) 
    procedure: (string-ci<=? string1 string2 string3 ...) 
    procedure: (string-ci>=? string1 string2 string3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs unicode), (rnrs)

    *case-insensitive*
*** procedure: (string char ...) 
    returns: a string containing the characters char ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-string n) 
    procedure: (make-string n char) 
    returns: a string of length n 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-length string) 
    returns: the number of characters in string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-ref string n) 
    returns: the nth character (zero-based) of string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-set! string n char) 
    returns: unspecified 
    libraries: (rnrs mutable-strings)
*** procedure: (string-copy string) 
    returns: a new copy of string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-append string ...) 
    returns: a new string formed by concatenating the strings string ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (substring string start end) 
    returns: a copy of string from start (inclusive) to end (exclusive) 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-fill! string char) 
    returns: unspecified 
    libraries: (rnrs mutable-strings)
*** procedure: (string-upcase string) 
    returns: the upper-case equivalent of string 
    procedure: (string-downcase string) 
    returns: the lower-case equivalent of string 
    procedure: (string-foldcase string) 
    returns: the case-folded equivalent of string 
    procedure: (string-titlecase string) 
    returns: the title-case equivalent of string 
    libraries: (rnrs unicode), (rnrs)
*** procedure: (string-normalize-nfd string) 
    returns: the Unicode normalized form D of string 
    procedure: (string-normalize-nfkd string) 
    returns: the Unicode normalized form KD of string 
    procedure: (string-normalize-nfc string) 
    returns: the Unicode normalized form C of string 
    procedure: (string-normalize-nfkc string) 
    returns: the Unicode normalized form KC of string 
    libraries: (rnrs unicode), (rnrs)
*** procedure: (string->list string) 
    returns: a list of the characters in string 
    libraries: (rnrs base), (rnrs)
*** procedure: (list->string list) 
    returns: a string of the characters in list 
    libraries: (rnrs base), (rnrs)
** 6.9.Vectors
   对于某些应用程序，向量比列表更方便和有效。
   Vectors的随机访问时常量复杂度O1，列表的随机访问时线性复杂度On
   Vectors打印形式： #(obj0 obj1 obj2 ...)

*** procedure: (vector obj ...) 
    returns: a vector of the objects obj ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-vector n) 
    procedure: (make-vector n obj) 
    returns: a vector of length n 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-length vector) 
    returns: the number of elements in vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-ref vector n) 
    returns: the nth element (zero-based) of vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-set! vector n obj) 
    returns: unspecified 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-fill! vector obj) 
    returns: unspecified 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector->list vector) 
    returns: a list of the elements of vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (list->vector list)
    returns: a vector of the elements of list 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-sort predicate vector)
    returns: a vector containing the elements of vector, sorted according to predicate 
    procedure: (vector-sort! predicate vector) 
    returns: unspecified 
    libraries: (rnrs sorting), (rnrs)
** 6.10.ByteVectors
   Bytevectors是原始二进制数据的向量。
   bytevector的长度是它存储的8位字节的数量，而bytevector中的索引总是作为字节偏移量给出。
** 6.11.Symbols
   符号
   字符串可以用于大多数相同的目的，但符号的一个重要特征使得符号之间的比较更加有效。
   (eq? 'aaa 'aaa) ;; #t
   (eq? "aaa" "aaa") ;; #f
   原因是Scheme读取器（由get-datum和read调用）和过程string-> symbol目录符号在内部符号表中，
   并且每当遇到相同的名称时始终返回相同的符号。避免逐个字符比较
   应用：
   - 程序表示中的标识符
   - 符号可以用作过程之间传递的消息
   - 列表结构记录的标签，
   - 存储在关联列表中的对象的名称
*** procedure: (symbol=? symbol1 symbol2) 
    returns: #t if the two symbols are the same, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (string->symbol string) 
    returns: a symbol whose name is string 
    libraries: (rnrs base), (rnrs)
*** procedure: (symbol->string symbol) 
    returns: a string, the name of symbol 
    libraries: (rnrs base), (rnrs)
** 6.12.Booleans
*** procedure: (boolean=? boolean1 boolean2)
    returns: #t if the two booleans are the same, #f otherwise 
    libraries: (rnrs base), (rnrs)

    boolean=? #t #t) <graphic> #t
    (boolean=? #t #f) <graphic> #f
    (boolean=? #t (< 3 4)) <graphic> #t
** 6.13.Hashtables
   Hashtables表示任意Scheme值之间的关联集。
   但是当涉及大量关联时通常要快得多。

*** procedure: (make-eq-hashtable) 
    procedure: (make-eq-hashtable size) 
    returns: a new mutable eq hashtable 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (make-eqv-hashtable) 
    procedure: (make-eqv-hashtable size) 
    returns: a new mutable eqv hashtable 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (make-hashtable hash equiv?) 
    procedure: (make-hashtable hash equiv? size) 
    returns: a new mutable hashtable 
    libraries: (rnrs hashtables), (rnrs)
    
    (define ht (make-hashtable string-hash string=?))

*** procedure: (hashtable-mutable? hashtable) 
    returns: #t if hashtable is mutable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-hash-function hashtable) 
    returns: the hash function associated with hashtable 
    procedure: (hashtable-equivalence-function hashtable) 

*** procedure: (equal-hash obj) 
    procedure: (string-hash string) 
    procedure: (string-ci-hash string) 
    procedure: (symbol-hash symbol) 
    returns: an exact nonnegative integer hash value 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-set! hashtable key obj) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-ref hashtable key default) 
    returns: see below 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-contains? hashtable key)
    returns: #t if an association for key exists in hashtable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-update! hashtable key procedure default) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-delete! hashtable key) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-size hashtable)
    returns: number of entries in hashtable 
    libraries: (rnrs hashtables), (rnrs)
*** More procedures
    ...
** 6.14.Enumerations
   枚举是有序的符号集，通常用于命名和操作选项，
   与创建文件时可能指定的缓冲区模式和文件选项一样。
*** syntax: (define-enumeration name (symbol ...) constructor) 
    libraries: (rnrs enums), (rnrs)

    - name 用于验证symble是否为枚举中的symble
      如果symble是枚举值，则返回该symble，否则抛出异常；
    - constructor 可用于创建枚举类型的子集。
      (construct x...)如果x...是name对应枚举的子集，则OK，否则句法违规
    
*** procedure: (make-enumeration symbol-list) 
    returns: an enumeration set 
    libraries: (rnrs enums), (rnrs)

    根据列表结合创建 枚举集合
*** procedure: (enum-set-constructor enum-set)
    returns: an enumeration-set construction procedure 
    libraries: (rnrs enums), (rnrs)

    根据枚举集合创建 枚举构造器
*** procedure: (enum-set-universe enum-set) 
    returns: the universe of enum-set, as an enumeration set 
    libraries: (rnrs enums), (rnrs)

    获取所有枚举项

*** procedure: (enum-set->list enum-set) 
    returns: a list of the elements of enum-set 
    libraries: (rnrs enums), (rnrs)
    
    将枚举集合转换为列表；

*** procedure: (enum-set-subset? enum-set1 enum-set2) 
    returns: #t if enum-set1 is a subset of enum-set2, #f otherwise 
    libraries: (rnrs enums), (rnrs)
    判断set1 是否为 set2的子集

*** procedure: (enum-set=? enum-set1 enum-set2)
    returns: #t if enum-set1 and enum-set2 are equivalent, #f otherwise 
    libraries: (rnrs enums), (rnrs)
    判断子集是否相等
    
    
*** procedure: (enum-set-member? symbol enum-set) 
    returns: #t if symbol is an element of enum-set, #f otherwise 
    libraries: (rnrs enums), (rnrs)

    判断 symbol 是否为 enum-set的成员

*** procedure: (enum-set-union enum-set1 enum-set2) 
    returns: the union of enum-set1 and enum-set2 
    并集
    procedure: (enum-set-intersection enum-set1 enum-set2) 
    returns: the intersection of enum-set1 and enum-set2 
    交集
    procedure: (enum-set-difference enum-set1 enum-set2) 
    returns: the difference of enum-set1 and enum-set2 
    libraries: (rnrs enums), (rnrs)
    差集

*** procedure: (enum-set-complement enum-set) 
    returns: the complement of enum-set relative to its universe 
    libraries: (rnrs enums), (rnrs)

    获取与超级的差集
    
*** procedure: (enum-set-projection enum-set1 enum-set2) 
    returns: the projection of enum-set1 into the universe of enum-set2 
    libraries: (rnrs enums), (rnrs)

    枚举set1的任何元素都不在enum-set2的Universe中。结果与enum-set2具有相同的枚举类型。
    公共超集的最大子集
    
*** procedure: (enum-set-indexer enum-set) 
    returns: a procedure that returns the index of a symbol in the universe of enum-set 
    libraries: (rnrs enums), (rnrs)
    
    获取一个记录枚举集合下标的过程，用于计算枚举项的下标值；
* 7. Input and Output(I/O)
  所有输入和输出操作都通过端口(port)执行。
  端口是指向（可能是无限的）数据流（通常是文件）的指针，程序可以从流中抽取字节或字符或将字节或字符放入流中的开口。
  端口可以​​是输入端口，输出端口或两者同时。
  Ports是一等对象，就像Scheme中的任何其他对象一样。
  与过程类似，端口没有字符串和数字的打印表示。
  最初有三个端口：当前输入端口，当前输出端口和当前错误端口，它们是连接到进程标准输入，标准输出和标准错误流的文本端口。
  提供了几种打开新端口的方法。
  
  输入端口通常指向有限流，如存储在磁盘上的输入文件。
  如果其中一个输入操作（例如get-u8，get-char或get-datum）被要求从已到达有限流末尾的端口读取，则返回一个特殊的eof（文件结束）对象。
  谓词eof-object？可用于确定从输入操作返回的值是否是eof对象。

  端口是二进制(binary)或文本(textual)。
  二进制端口允许程序从底层流中读取或写入8位无符号字节或“八位字节”。
  文本端口允许程序读取或写入字符。

  在许多情况下，底层流被组织为一个字节序列，但这些字节应被视为字符的编码。
  在这种情况下，可以使用代码转换器创建文本端口，以将字节解码为字符（用于输入）或将字符编码为字节（用于输出）。

  代码转换器封装了一个编解码器，用于确定字符如何表示为字节。
  提供了三种标准编解码器：latin-1编解码器，Unicode utf-8编解码器和Unicode utf-16编解码器。
  - 对于latin-1编码，每个字符仅由一个字节表示。
  - 对于utf-8，每个字符由一到四个字节表示，
  - 对于utf-16，每个字符由二到四个字节表示，
  
  转码器还封装了一个eol样式，用于确定是否以及如何识别行结尾。
  如果eol样式为none，则不会识别行结尾。其他六种标准eol样式如下：
  lf：换行符
  cr：回车符
  nel：Unicode下一行字符
  ls：Unicode行分隔符
  crlf：回车后跟换行
  crnel：回车后跟下一行

  eol样式以不同方式影响输入和输出操作。
  对于输入，除了none之外的任何eol样式都会将每个行结束字符或双字符序列转换为单个换行符。
  对于输出，除了none之外的任何eol样式都会将换行符转换为与eol样式关联的特定单字符或双字符序列。
  在输入方向上，除了none之外的所有eol样式都是等效的，而在输出方向上，eol样式none和lf是等效的。

  除了编解码器和eol风格之外，转码器还封装了另外一条信息：
  一种错误处理模式，用于确定在发生解码或编码错误时发生的情况，
  即，如果字节序列无法转换为输入方向上带有封装编解码器的字符，
  或者字符无法转换为字节序列封装的编解码器在输出方向上。
  
  错误处理模式是忽略，异常或替换。
  如果忽略错误处理模式，则忽略有问题的字节序列或字符。
  如果异常错误处理模式，则会引发条件类型为i / o-decoding或i / o-encoding的异常;
  在输入方向上，端口位于字节序列之外
  如果错误处理模式为replace，则会生成替换字符或字符编码：
  在输入方向上，替换字符是U + FFFD，而在输出方向上，替换是utf-8和utf-16编解码器的U + FFFD编码或问号字符的编码（？）对于latin-1编解码器。
  
  可以缓冲端口以提高效率，消除每个字节或字符对操作系统的调用开销。
  支持三种标准缓冲模式：块(block)，行(line)和没有(none)。
  使用块缓冲，从流中提取输入，并以一些与实现相关的大小的块发送输出到流。
  使用行缓冲，缓冲是逐行或依赖于某些其他实现进行的。
  行缓冲通常仅与文本输出端口的块缓冲区别开来;
  二进制端口中没有行划分，并且可能在流可用时从流中抽取输入。
  如果没有缓冲模式，则不执行缓冲，因此输出会立即发送到流，并且仅在需要时输入输入。

  章的其余部分介绍了对代码转换器，文件端口，标准端口，字符串和字节向量端口，自定义端口，
  常规端口操作，输入操作，输出操作，便捷I / O，文件系统操作以及字节向量和字符串之间的转换的操作。

** 7.1.Transcoders(转码器)
   转码器封装了三个值：编解码器，eol样式和错误处理模式。
   本节介绍了在转码器上创建或操作的过程以及转码器封装的值。
*** procedure: (make-transcoder codec) 
    procedure: (make-transcoder codec eol-style) 
    procedure: (make-transcoder codec eol-style error-handling-mode) 
    returns: a transcoder encapsulating codec, eol-style, and error-handling-mode 
    libraries: (rnrs io ports), (rnrs)
    
    创建转码器
    codec latin-1,utf-8,utf-16
    eol-style must be a valid eol-style symbol (lf, cr, nel, ls, crlf, crnel, or none);
              它默认为平台的原生eol风格。
    error-handling-mode 错误处理模式必须是有效的错误处理模式符号（忽略，提升或替换），并且默认为替换。
*** procedure: (transcoder-codec transcoder) 
    returns: the codec encapsulated in transcoder 
    procedure: (transcoder-eol-style transcoder) 
    returns: the eol-style symbol encapsulated in transcoder 
    procedure: (transcoder-error-handling-mode transcoder) 
    returns: the error-handling-mode symbol encapsulated in transcoder 
    libraries: (rnrs io ports), (rnrs)

    获取转码器的编码器，换行模式，错误处理模式
*** procedure: (native-transcoder) 
    returns: the native transcoder 
    libraries: (rnrs io ports), (rnrs)

    本机代码转换器依赖于实现，可能因平台或语言环境而异。
*** procedure: (latin-1-codec) 
    returns: a codec for ISO 8859-1 (Latin 1) character encodings 
    procedure: (utf-8-codec) 
    returns: a codec for Unicode UTF-8 character encodings 
    procedure: (utf-16-codec) 
    returns: a codec for Unicode UTF-16 character encodings 
    libraries: (rnrs io ports), (rnrs)

    创建编码器
*** syntax: (eol-style symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
    检测行结束格式。
    (eol-style crlf) <graphic> crlf
    (eol-style lfcr) <graphic> syntax violation
*** procedure: (native-eol-style) 
    returns: the native eol style 
    libraries: (rnrs io ports), (rnrs)
*** syntax: (error-handling-mode symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
** 7.2.OpeningFiles(打开文件)
   每个文件打开操作都接受一个路径参数，该参数命名要打开的文件。
   它必须是一个字符串或一些其他依赖于实现的值来命名文件。
   
   一些文件打开过程接受可选选项，b-mode和?transcoder参数。
   options必须是在下面的file-options条目中描述的构成有效文件选项的符号上设置的枚举，并且默认为（file-options）的值。
   b-mode必须是下面缓冲模式条目中描述的有效缓冲模式，并且默认为block。
   ?transcoder必须是 transcoder或#f;
   如果它是代码转换器，则打开操作返回基础二进制文件的转码端口，而如果它是#f（默认值），则打开操作返回二进制端口
   本节中的过程创建的二进制端口支持port-position,set-port-position!！操作。
   
*** syntax: (file-options symbol ...)
    returns: a file-options enumeration set 
    libraries: (rnrs io ports), (rnrs)
    有三种标准文件选项：no-create，no-fail和no-truncate，它只影响创建输出（包括输入/​​输出）端口的文件打开操作。
    
    默认选项如果文件已存在，则引发条件类型i / o-file-already-exists的异常，
    如果文件尚不存在则创建该文件。
    如果包含no-fail选项，则如果文件已存在则不会引发异常;相反，文件被打开并截断为零长度。
    
*** syntax: (buffer-mode symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
    必须是 block, line, or none. 

*** syntax: (buffer-mode? obj) 
    returns: #t if obj is a valid buffer mode, #f otherwise 
    libraries: (rnrs io ports), (rnrs)
    判断是否合法的模式

*** procedure: (open-file-input-port path) 
    procedure: (open-file-input-port path options) 
    procedure: (open-file-input-port path options b-mode) 
    procedure: (open-file-input-port path options b-mode ?transcoder) 
    returns: a new input port for the named file 
    libraries: (rnrs io ports), (rnrs)

    打开文件输入端口，读取文件
    
*** procedure: (open-file-output-port path) 
    procedure: (open-file-output-port path options) 
    procedure: (open-file-output-port path options b-mode) 
    procedure: (open-file-output-port path options b-mode ?transcoder) 

    打开文件输出端口，写入文件

*** procedure: (open-file-input/output-port path) 
    procedure: (open-file-input/output-port path options) 
    procedure: (open-file-input/output-port path options b-mode) 
    procedure: (open-file-input/output-port path options b-mode ?transcoder) 
    returns: a new input/output port for the named file 
    libraries: (rnrs io ports), (rnrs)

    打开文件读写端口；

** 7.3.Standard Ports
   本节中描述的过程返回附加到进程标准输入，标准输出和标准错误流的端口。
   
*** procedure: (current-input-port) 
    returns: the current input port 
    procedure: (current-output-port) 
    returns: the current output port 
    procedure: (current-error-port) 
    returns: the current error port 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)

    当前文本输入输出端口
    
*** procedure: (standard-input-port) 
    returns: a fresh binary input port connected to the standard input stream 
    procedure: (standard-output-port) 
    returns: a fresh binary output port connected to the standard output stream 
    procedure: (standard-error-port) 
    returns: a fresh binary output port connected to the standard error stream 
    libraries: (rnrs io ports), (rnrs)
    
    标准文本输入输出端口

** 7.4.String and Bytevector Ports
   本节中的过程允许将字节向量和字符串用作输入或输出流。
   
   
*** procedure: (open-bytevector-input-port bytevector) 
    procedure: (open-bytevector-input-port bytevector ?transcoder) 
    returns: a new input port that draws input from bytevector 
    libraries: (rnrs io ports), (rnrs)

    无需关闭bytevector端口;

*** procedure: (open-string-input-port string) 
    returns: a new textual input port that draws input from string 
    libraries: (rnrs io ports), (rnrs)

    无需关闭字符串端口;
    
*** procedure: (open-bytevector-output-port) 
    procedure: (open-bytevector-output-port ?transcoder) 
    returns: two values, a new output port and an extraction procedure 
    libraries: (rnrs io ports), (rnrs)

    返回多值-2个过程，一个操作，一个提取
*** procedure: (open-string-output-port) 
    returns: two values, a new textual output port and an extraction procedure 
    libraries: (rnrs io ports), (rnrs)

    返回多值-2个过程，一个操作，一个提取
*** procedure: (call-with-bytevector-output-port procedure) 
    procedure: (call-with-bytevector-output-port procedure ?transcoder) 
    returns: a bytevector containing the accumulated bytes 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (call-with-string-output-port procedure) 
    returns: a string containing the accumulated characters 
    libraries: (rnrs io ports), (rnrs)

** 7.5.Opeing Custom Ports
*** procedure: (make-custom-binary-input-port id r! gp sp! close)
    returns: a new custom binary input port 
    procedure: (make-custom-binary-output-port id w! gp sp! close) 
    returns: a new custom binary output port 
    procedure: (make-custom-binary-input/output-port id r! w! gp sp! close) 
    returns: a new custom binary input/output port 
    libraries: (rnrs io ports), (rnrs)


    这些过程允许程序从任意字节流创建端口。 id必须是一个命名新端口的字符串;
    id 该名称仅用于提供信息，实现可以选择将其包含在自定义端口的打印语法（如果有）中。
    创建自定义二进制输入/输出端口的程序通常应提供gp和sp！程序。

    - r! (read procedure) 读取输入，支持get-u8,get-bytevector-n.
      它使用三个参数调用：bytevector，start和n。从向量的start处读取n个字节
      如果字节流在文件末尾，r！应该返回0。否则，它应该从流中读取至少一个且最多n个字节，
      将这些字节存储在从start开始的bytevector的连续位置，并以实数正整数形式返回实际读取的字节数。
    - w! (write procedure) 调用w!将输出发送到端口，
      它使用三个参数调用：bytevector，start和n。写入start后的n字节到端口。
    - gp (get position) 被调用来查询端口的位置。
      如果是#f，则端口不支持端口位置。
      (gp) ;; position
    - sp! (set port's position) 
      如果是#f，端口将不支持set-port-position！
      (sp! 1253) ;; 设置由标位置
    - close 被调用来关闭字节流。
      如果是#f，则在关闭新端口时不会采取任何操作来关闭字节流。
      (close) ;;#f 无操作，#t 进行必要操作

*** procedure: (make-custom-textual-input-port id r! gp sp! close) 
    returns: a new custom textual input port 
    procedure: (make-custom-textual-output-port id w! gp sp! close) 
    returns: a new custom textual output port 
    procedure: (make-custom-textual-input/output-port id r! w! gp sp! close) 
    returns: a new custom textual input/output port 
    libraries: (rnrs io ports), (rnrs)

** 7.6.Port Operations
   不涉及读/写操作
   
*** procedure: (port? obj) 
    returns: #t if obj is a port, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

    procedure: (input-port? obj) 
    returns: #t if obj is an input or input/output port, #f otherwise 
    procedure: (output-port? obj) 
    returns: #t if obj is an output or input/output port, #f otherwise 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)
    
    procedure: (binary-port? obj) 
    returns: #t if obj is a binary port, #f otherwise 
    procedure: (textual-port? obj) 
    returns: #t if obj is a textual port, #f otherwise 
    libraries: (rnrs io ports), (rnrs)
    
*** procedure: (close-port port)
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
    
    应该手动调用close-port，不应该依赖于系统close。关闭已关闭的端口不会报错，只是忽略该操作。
    
*** procedure: (transcoded-port binary-port transcoder) 
    returns: a new textual port with the same byte stream as binary-port 
    libraries: (rnrs io ports), (rnrs)
    
    此过程返回一个带有代码转换器代码转换器的新文本端口，以及与二进制端口相同的基础字节流，位于二进制端口的当前位置。
    作为创建文本端口的副作用，二进制端口被关闭以防止二进制端口上的读取或写入操作干扰新文本端口上的读取和写入操作。
    然而，基础字节流保持打开状态，直到文本端口关闭。
    stream(open)-->binary-port(open)
    stream(open)-->binary-port(close) ;;防止干扰textual-port，被关闭
    stream(open)-->textual-port(open)
    stream(close)-->textual-port(close)

*** procedure: (port-transcoder port) 
    returns: the transcoder associated with port if any, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (port-position port) 
    returns: the port's current position 
    procedure: (port-has-port-position? port) 
    returns: #t if the port supports port-position, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (set-port-position! port pos) 
    returns: unspecified 
    procedure: (port-has-set-port-position!? port) 
    returns: #t if the port supports set-port-position!, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (call-with-port port procedure) 
    returns: the values returned by procedure 
    libraries: (rnrs io ports), (rnrs)
    
    call-with-port调用过程，将port作为唯一参数。
    如果procedure返回，call-with-port将关闭端口并返回procedure返回的值。
    如果在过程外创建的 *延续被调用* ，call-with-port不会自动关闭端口，
    因为有可能在稍后的时间调用在过程内创建的另一个继续，将控制返回到过程。
    如果过程没有返回，则只有在可以证明输出端口不再可访问的情况下，实现才可以自由关闭端口。
    
    下面的示例将infile的内容复制到outfile，如果存在则覆盖outfile。
    除非发生错误，否则在复制完成后将关闭端口。

    #+BEGIN_SRC scheme
    (call-with-port (open-file-input-port "infile" (file-options)
                      (buffer-mode block) (native-transcoder))
      (lambda (ip)
        (call-with-port (open-file-output-port "outfile"
                          (file-options no-fail)
                          (buffer-mode block)
                          (native-transcoder)) 
          (lambda (op)
            (do ([c (get-char ip) (get-char ip)])
                ((eof-object? c))
              (put-char op c))))))
    #+END_SRC

*** procedure: (output-port-buffer-mode port) 
    returns: the symbol representing the buffer mode of port 
    libraries: (rnrs io ports), (rnrs)

** 7.7.Input Operations
   本节描述了主要目的是从输入端口读取数据的过程，以及用于识别或创建文件结束（eof）对象的相关过程。
   
*** procedure: (eof-object? obj) 
    returns: #t if obj is an eof object, #f otherwise 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)

    当输入端口到达输入结束时，输入操作（例如，get-datum）返回文件结束对象。

*** procedure: (eof-object) 
    returns: the eof object 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)
    #+BEGIN_SRC scheme
    (eof-object? (eof-object)) ;; #t
    #+END_SRC
    
*** procedure: (get-u8 binary-input-port) 
    returns: the next byte from binary-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)
    
    读取一个无符号字节(0~255),游标+1
    或读取到eof
    #+BEGIN_SRC scheme
    ;;; 将字节向量读取到列表中，包括!eof
    (let* ((vec-num #vu8(0 1 2 3 4 5 6 7 8 9))
           [vec-reader (open-bytevector-input-port vec-num)]
           [vec-len (bytevector-length vec-num)])
      (do ([i 0 (+ i 1)] [vals (list) (append vals (list (get-u8 vec-reader)))])
          ([> i vec-len] vals)))
    #+END_SRC

*** procedure: (lookahead-u8 binary-input-port) 
    returns: the next byte from binary-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)
    
    如果binary-input-port位于文件末尾，则返回eof对象。
    否则，下一个可用字节作为无符号8位数返回，即，小于或等于255的精确无符号整数。
    与get-u8相比，lookahead-u8不消耗它从端口读取的字节，因此如果端口上的下一个操作是对lookahead-u8或get-u8的调用，则返回相同的字节。
    
*** procedure: (get-bytevector-n binary-input-port n) 
    returns: a nonempty bytevector containing up to n bytes, or the eof object 
    libraries: (rnrs io ports), (rnrs)

    返回字节向量，游标后移n字节或!eof

*** procedure: (get-bytevector-n! binary-input-port bytevector start n) 
    returns: the count of bytes read or the eof object 
    libraries: (rnrs io ports), (rnrs)

    如果binary-input-port位于文件末尾，则返回eof对象。否则，get-bytevector-n！读取（就像使用get-u8一样多）字节，最多为n，
    在端口处于文件结尾之前可用，将字节存储在从start开始的bytevector的连续位置，并返回读取的字节数精确的正整数。端口的位置超过读取的字节数。

*** procedure: (get-bytevector-some binary-input-port) 
    returns: a nonempty bytevector or the eof object 
    libraries: (rnrs io ports), (rnrs)
    如果binary-input-port位于文件末尾，则返回eof对象。
    否则，get-bytevector-some读取（就像使用get-u8一样）至少一个字节甚至更多，并返回包含这些字节的bytevector。
    端口的位置超过读取的字节数。此操作读取的最大字节数取决于实现。

*** procedure: (get-bytevector-all binary-input-port) 
    returns: a nonempty bytevector or the eof object 
    libraries: (rnrs io ports), (rnrs)
    如果binary-input-port位于文件末尾，则返回eof对象。
    否则，get-bytevector-all读取（就像使用get-u8一样）在端口位于文件末尾之前可用的所有字节，
    并返回包含这些字节的bytevector。端口的位置超过读取的字节数。

*** procedure: (get-char textual-input-port) 
    returns: the next character from textual-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)
    
*** procedure: (lookahead-char textual-input-port) 
    returns: the next character from textual-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)
    
    #+BEGIN_SRC scheme
    ;;; 读取一个单词
    (define get-word
      (lambda (p)
        (list->string
          (let f ()
            (let ([c (lookahead-char p)])
              (cond
                [(eof-object? c) '()]
                [(char-alphabetic? c) (get-char p) (cons c (f))]
                [else '()]))))))
    #+END_SRC
*** procedure: (get-string-n textual-input-port n) 
    returns: a nonempty string containing up to n characters, or the eof object 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (get-string-n! textual-input-port string start n) 
    returns: the count of characters read or the eof object 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (get-string-all textual-input-port) 
    returns: a nonempty string or the eof object 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (get-line textual-input-port) 
    returns: a string or the eof object 
    libraries: (rnrs io ports), (rnrs)
    #+BEGIN_SRC scheme
    (let ([sip (open-string-input-port "one\ntwo\n")])
      (let* ([s1 (get-line sip)] [s2 (get-line sip)])
        (list s1 s2 (port-eof? sip)))) ;; ("one" "two" #t) 

    (let ([sip (open-string-input-port "one\ntwo")])
      (let* ([s1 (get-line sip)] [s2 (get-line sip)])
        (list s1 s2 (port-eof? sip)))) ;; ("one" "two" #t)
    #+END_SRC
*** procedure: (get-datum textual-input-port) 
    returns: a Scheme datum object or the eof object 
    libraries: (rnrs io ports), (rnrs)

    此过程扫描过去的空格和注释，以查找数据外部表示的开始。
    get-datum根据需要读取多个字符，而不再读取单个数据，并返回一个新分配的对象，其结构由外部表示确定。
    游标后移读取字节数。
    如果在完成数据之前到达文件结尾，或者读取了意外字符，则会引发条件类型＆词法和i / o-read的异常。
    #+BEGIN_SRC scheme
    ;;; 读取数据
    (let ([sip (open-string-input-port "; a\n\n one (two)\n")])
      (let* ([x1 (get-datum sip)]
             [c1 (lookahead-char sip)]
             [x2 (get-datum sip)])
        (list x1 c1 x2 (port-eof? sip)))) ;; (one #\space (two) #f)
    #+END_SRC
*** procedure: (port-eof? input-port) 
    returns: #t if input-port is at end-of-file, #f otherwise 
    libraries: (rnrs io ports), (rnrs)
** 7.8.OutputOperations
   本节描述了主要用于将数据发送到输出端口的过程。
*** procedure: (put-u8 binary-output-port octet) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (put-bytevector binary-output-port bytevector) 
    procedure: (put-bytevector binary-output-port bytevector start) 
    procedure: (put-bytevector binary-output-port bytevector start n) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (put-char textual-output-port char) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (put-string textual-output-port string) 
    procedure: (put-string textual-output-port string start) 
    procedure: (put-string textual-output-port string start n) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (put-datum textual-output-port obj) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (flush-output-port output-port) 
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
    此过程强制将与output-port关联的缓冲区中的任何字节或字符立即发送到基础流。
** 7.9.Convenience I/O
   可以使用或不使用显式端口参数来调用便利输入/输出过程。
   如果在没有显式端口参数的情况下调用，则会根据需要使用当前输入或输出端口。
   例如，（read-char）和（read-char（current-input-port））都返回当前输入端口的下一个字符。
*** procedure: (open-input-file path) 
    returns: a new input port 
    libraries: (rnrs io simple), (rnrs)
    path必须是一个字符串或一些其他依赖于实现的值来命名文件。 
    open-input-file为path命名的文件创建一个新的文本输入端口，
    就像使用带有默认选项的open-file-input-port，依赖于实现的缓冲模式和依赖于实现的转码器一样。
*** procedure: (open-output-file path) 
    returns: a new output port 
    libraries: (rnrs io simple), (rnrs)

    #+BEGIN_SRC scheme
    ;;; 写文件
    (let ([p (open-output-file "myfile.ss")])
      (let f ([ls list-to-be-printed])
        (if (not (null? ls))
            (begin
              (write (car ls) p)
              (newline p)
              (f (cdr ls)))))
      (close-port p))

    ;;; 读文件
    (let ([port (open-input-file "myfile.ss")])
      (lef f ([x (read port)])
           (begin
             (close-port p)
             '())
           (cons x (f (read port)))))
    #+END_SRC
*** procedure: (call-with-input-file path procedure) 
    returns: the values returned by procedure 
    libraries: (rnrs io simple), (rnrs)

    解耦合文件打开和文件处理；
    call-with-input-file为path命名的文件创建一个新的输入端口，就像使用open-input-file一样，并将此端口传递给procedure。
    如果procedure返回，call-with-input-file将关闭输入端口并返回procedure返回的值。
*** procedure: (call-with-output-file path procedure) 
    returns: the values returned by procedure 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (with-output-to-file path thunk) 
    returns: the values returned by thunk 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (read) 
    procedure: (read textual-input-port) 
    returns: a Scheme datum object or the eof object 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (read-char) 
    procedure: (read-char textual-input-port) 
    returns: the next character from textual-input-port 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (peek-char) 
    procedure: (peek-char textual-input-port) 
    returns: the next character from textual-input-port 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (write obj) 
    procedure: (write obj textual-output-port) 
    returns: unspecified 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (display obj) 
    procedure: (display obj textual-output-port) 
    returns: unspecified 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (write-char char) 
    procedure: (write-char char textual-output-port) 
    returns: unspecified 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (newline) 
    procedure: (newline textual-output-port) 
    returns: unspecified 
    libraries: (rnrs io simple), (rnrs)
*** procedure: (close-input-port input-port) 
    procedure: (close-output-port output-port) 
    returns: unspecified 
    libraries: (rnrs io simple), (rnrs)
** 7.10.FilesystemOperations
*** procedure: (file-exists? path)
   returns: #t if the file named by path exists, #f otherwise 
   libraries: (rnrs files), (rnrs)
*** procedure: (delete-file path) 
    returns: unspecified 
    libraries: (rnrs files), (rnrs)
** 7.11.ByteVector/String Conversions
*** procedure: (bytevector->string bytevector transcoder) 
    returns: a string containing the characters encoded in bytevector 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (string->bytevector string transcoder) 
    returns: a bytevector containing the encodings of the characters in string 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (string->utf8 string) 
    returns: a bytevector containing the UTF-8 encoding of string 
    libraries: (rnrs bytevectors), (rnrs)
    
    procedure: (string->utf16 string) 
    procedure: (string->utf16 string endianness) 
    procedure: (string->utf32 string) 
    procedure: (string->utf32 string endianness) 
*** procedure: (utf8->string bytevector) 
    returns: a string containing the UTF-8 decoding of bytevector 
    libraries: (rnrs bytevectors), (rnrs)

    procedure: (utf16->string bytevector endianness) 
    procedure: (utf16->string bytevector endianness endianness-mandatory?) 
    procedure: (utf32->string bytevector endianness) 
    procedure: (utf32->string bytevector endianness endianness-mandatory?) 
    returns: a string containing the specified decoding of bytevector 
    libraries: (rnrs bytevectors), (rnrs)
* 8. Syntatic Extension
** introduce
   语法扩展或宏用于简化和规范程序中的重复模式，
   使用新的计算规则引入语法形式，并执行有助于提高程序效率的转换。

   语法扩展通常采用形式(keyword subform...），其中keyword是命名语法扩展的标识符。
   每个subform描述从一个语法扩展到另外一个。
   语法扩展可以采用非常规列表或单个标识符
   
   通过将关键字与转换过程或变换器相关联来定义新的语法扩展。
   使用define-syntax形式或使用let-syntax或letrec-syntax定义语法扩展。
   使用syntax-rules创建转化器，这允许执行简单的基于模式的转换。
   它们也可以是接受一个参数并执行任意计算的普通过程。syntax-case ,syntax
   identifier-syntax,make-variable-transformer,syntax-rules.

   语法扩展器(syntax expander)在计算开始时（编译或解释之前）将语法扩展扩展为核心形式。
   如果扩展器遇到语法扩展，它调用相关的变换器来扩展语法扩展，
   如果扩展器遇到核心语法形式,它递归处理子form（如果有），并从展开的subform重构表单。
   在扩展期间维护有关标识符绑定的信息，以强制执行变量和关键字的词法作用域。

   可从 http://www.cs.indiana.edu/syntax-case/ 获得该系统的便携式实现，该系统还支持库和顶级程序。
** 8.1.Keyword Binding
   本节介绍在关键字和变换器之间建立绑定的forms。
   可以使用define-syntax在top-level或库主体中建立关键字绑定，
   并使用define-syntax，let-syntax或letrec-syntax在任何本地范围内建立关键字绑定。
*** syntax: (define-syntax keyword expr) 
    libraries: (rnrs base), (rnrs)
    
    expr must evaluate to a transformer(转换器).
    #+BEGIN_SRC scheme
    ;;; 等以let*语法扩展
    ;;; step1. 调用define-syntax let* 关键字
    (define-syntax let*
      ;;; step2. 创建转换规则
      (syntax-rules ()
        [(_ () b1 b2 ...) (let () b1 b2 ...)]
        [(_ ([i1 e1] [i2 e2] ...) b1 b2...)
         (let ([i1 e1])
           ;;; 注意，递归调用自身
           (let* ([i2 e2] ...) b1 b2 ...))]))
    #+END_SRC

    所有绑定都由一组内部定义建立，关键字或变量定义在直接封闭体内的任何地方都可见，包括在定义本身内。
    
    #+BEGIN_SRC scheme
    (let ()
      ;;; 内部可见odd?
      (define even?
        (lambda (x)
          (or (= x 0) (odd? (- x 1)))))
      ;;; 内部可见even?
      (define-syntax odd?
        (syntax-rules ()
          [(_ x) (not (even? x))]))
      (even? 10))
    #+END_SRC

    扩展器(expander)在library,lambda,other body中从左到由的处理初始forms。
    如果遇到变量定义，它会记录定义的标识符是变量但延迟右侧表达式的扩展直到处理完所有定义之后的事实。
    如果遇到关键字定义，它会扩展并评估右侧表达式，并将关键字绑定到生成的转换器。
    如果遇到表达式，它会完全展开所有延迟的右侧表达式以及当前和剩余的正文表达式。

    从左到右处理顺序的含义是一个内部定义可以影响后续forms是否也是一个定义。

    #+BEGIN_SRC scheme
    (let ()
      (define-syntax bind-to-zero
        (syntax-rules ()
          [(_ id) (define id 0)]))
      (bind-to-zero y)
      y)

    (define y 1)
    y
    #;(bind-to-zero y) ;; Exception: variable bind-to-zero is not bound

    (define f
      (lambda (x)
        (+ x 1)))
    (f 1)
    (let-syntax ([f (syntax-rules ()
                      [(_ x) x])]
                 [g (syntax-rules ()
                      [(_ x) (f x)])])
      (list (f 1) (g 1)))
    #;(g 1) ;; Exception: variable g is not bound

    #+END_SRC
*** syntax: (let-syntax ((keyword expr) ...) form1 form2 ...) 
    syntax: (letrec-syntax ((keyword expr) ...) form1 form2 ...) 
    returns: see below 
    libraries: (rnrs base), (rnrs)

    每个expr必须是一个转换器。
    对于let-syntax和letrec-syntax两者，每个关键字都绑定在form1 
    form2 ....对于letrec-syntax，绑定范围还包括每个expr。

    以下示例重点介绍let-syntax和letrec-syntax的区别。
    #+BEGIN_SRC scheme
    (let ([f (lambda (x) (+ x 1))])
      (let-syntax ([f (syntax-rules ()
                           [(_ x) x])]
                   [g (syntax-rules ()
                        ;;;此处 f 绑定到 variable f,即(lambda ...)
                           [(_ x) (f x)])])
        (list (f 1) (g 1)))) ;; (1 2) 

    (let ([f (lambda (x) (+ x 1))])
      (letrec-syntax ([f (syntax-rules ()
                           [(_ x) x])]
                      [g (syntax-rules ()
                           ;;; 此处f绑定到 kewword f,即(syntax-rules ()...
                           [(_ x) (f x)])])
        (list (f 1) (g 1)))) ;; (1 1)
    #+END_SRC
** 8.2.Syntax-Rules Transformers
   本节中描述的syntax-rules允许以方便的方式指定简单的变换器(transformers)。
   可以使用这些机制(8.1 define-syntax,let-syntax,letrec-syntax)将这些变换器绑定到关键字。
   虽然表现力较差,不如8.3，它足以定义许多常见的语法扩展。
*** syntax: (syntax-rules (literal ...) clause ...) 
    returns: a transformer 
    libraries: (rnrs base), (rnrs)
    
    每个文字(literal)必须是下划线（_）或省略号（...）以外的标识符。
    每个条款(clause)必须采用以下形式。
    (pattern template)
    - pattern 模式
      模式由列表结构，向量结构，标识符和常量组成。
      模式中的每个标识符都是文字，模式变量，下划线或省略号。
      文字用作辅助关键字，例如case和cond表达式中的else。
      模式中的列表和向量结构指定输入所需的基本结构，
      下划线和模式变量指定任意子结构，
      文字和常量指定必须精确匹配的原子片段。
      省略号指定它们遵循的子模式的重复出现。

      输入形式F与模式P匹配，当且仅当：
      P是下划线或模式变量，
      P是文字标识符，F是具有相同绑定的标识符，由谓词free-identifier =？确定。
      P的形式为（P1 ... Pn），F是与P1到Pn匹配的n个元素的列表，
      
      语法规则模式的最外层结构实际上必须是上面列表结构形式之一，
    - template 模板
      模板是 模式变量，不是模式变量的标识符，模式数据，子模板列表（S1 ... Sn），非常规的子模板列表（S1 S2 ... Sn.T），
             子模板＃（S1 ... Sn）的矢量。
   
    #+BEGIN_SRC scheme
    (define-syntax or
      (syntax-rules ()
        [(_) #f]
        [(_ e) e]
        [(_ e1 e2 e3 ...)
         ;;;引入临时变量t，为了防止重复计算e1
         ;;; t 和 if 只在 or 词法范围有效，不影响外部的 t,if
         (let ([t e1]) (if t t (or e2 e3 ...)))]))

    ;;; 外部重定义 if, t 不影响 or 内部的 if,t
    ;;; or内部的if，t被妥善处理
    (let ([if #f])
      (let ([t 'okay])
        (or if t))) ;; okay
    #+END_SRC

    扩展器算法(expansion algorithm)会自动重命名本地标识符，以维护(lexical scoping)词法范围.

    #+BEGIN_SRC scheme
    ;;; 带参数 else
    ;;; 简单版本的cond
    (define-syntax cond
      (syntax-rules (else)
        [(_ (else e1 e2 ...)) (begin e1 e2 ...)]
        [(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]
        [(_ (e0 e1 e2 ...) c1 c2 ...)
         (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))
    #+END_SRC

*** syntax: _ 
    syntax: ... 
    libraries: (rnrs base), (rnrs syntax-case), (rnrs)
    
    _, ... 是 syntax-rules,identifier-syntax,syntax-case的辅助关键字
    ... 还是 syntax，quasisyntax的辅助关键字

*** syntax: (identifier-syntax tmpl) 
    syntax: (identifier-syntax (id1 tmpl1) ((set! id2 e2) tmpl2)) 
    returns: a transformer 
    libraries: (rnrs base), (rnrs)
    
    当关键字绑定到由第一种形式的identifier-syntax生成的转换器时，
    绑定范围内对关键字的引用将替换为tmpl。
    
    #+BEGIN_SRC scheme
    ;;; 相当于 别名
    (let ()
      (define-syntax a (identifier-syntax car))
      (list (a '(1 2 3)) a)) ;; (1 #<procedure>)

    (let ([ls (list 0)])
      (define-syntax a
        (identifier-syntax
          [id (car ls)]
          [(set! id e) (set-car! ls e)]))
      (let ([before a])
        (set! a 1)
        (list before a ls))) ;; (0 1 (1))
    #+END_SRC

** 8.3.Syntax-Case Transformers
   Syntax-Case 转换器
   本节描述了一种更具表现力的创建transformers的机制，syntax-case 是 syntax-rules的更通用版本。
   该机制允许指定任意复杂的变换器，包括控制“弯曲”词汇范围的转换，允许定义更广泛的语法扩展类。
   任何syntax-rules定义的转换器，都可以被syntax-case重写。甚至syntax-rules自身都是有syntax-case定义的。

   通过这种机制，变换器是一个参数的过程。参数是表示要处理的form的syntax object.返回值是表示输出form的syntax object。
   syntax object 是如下几种可能：非配对，非向量，非符号值，一对语法对象，语法对象的向量，或一个包装的语法对象。

   - 包装语法对象：包含其结构外还包含了form的上下文信息。扩展器使用此上下文信息来维护词法范围。
     包装还可能包含实现用于关联源代码和目标代码的信息，例如，通过扩展和编译过程跟踪文件，行和字符信息。
     必须为所有标识符提供上下文信息，这就是为什么上面的语法对象的定义不允许符号，除非它们被包装。
     表示标识符的语法对象本身称为标识符;
     术语标识符(idntifier)可以指语法实体（符号，变量或关键字）或语法实体的具体表示作为语法对象。
*** syntax: (syntax-case expr (literal ...) clause ...) 
    returns: see below 
    libraries: (rnrs syntax-case), (rnrs)
   
    每个literal必须是标识符。每个clause必须采用以下两种形式之一。
    
    (pattern output-expression)
    (pattern fender output-expression)

    syntax-case pattern 可以是第8.2节中描述的任何形式。
    
    ...
** 8.4.Examples
   
* 9. Records
  本章描述了程序员定义新数据类型(即记录,类型)的方法，每种类型都与所有其他类型不同。
  记录通过define-record-type form或make-record-type-descriptor procedure定义。
  
** 9.1.Define Records
   - define-record-type 定义一个记录类型，以及其构造过程，类型谓词，字段访问过程，字段赋值过程。
   - mutable 声明字段可变
   - immutable 声明字段不可变(默认不可变)
   - 可以自定义相关过程名称
   - (generative默认)相同代码每次调用define-record-type 都将产生新的记录类型
   - (nongenerative) 相同代码每次调用define-recorde-type 在相同词法域不产生新类型
     在不同词法域产生不同类型，但可以使用(nongenerative same-user-id)来指定不同词法域的相同类型
     但是鼓励程序员从RFC 4122 UUID名称空间[20]中选择uid，可能使用记录类型名称作为前缀。
   - 支持父记录类型，子记录类型；(继承)
   - (protocol) 使用protocol实现字段赋值程序化，不需要每个字段都手动赋值
     父类的存在导致更复杂的情况，
     (lambda (pargs->new)
      (lambda (x1 ... xn y1 ... ym)
       ((pargs->new x1 ... xn) y1 ... ym)))
     
   #+BEGIN_SRC scheme
   ;;; 定义一个点类型
   ;;;  具有2个字段 x, y;
   (define-record-type point (fields x y))
   ;;; define-record-type 自动定义出以下过程
   ;;; (make-point x y) constructor
   ;;; (point? obj)     predicate
   ;;; (point-x p)      accessor for field x
   ;;; (point-y p)      accessor for field y

   (define p (make-point 36 -17))
   (point? p) ;; #t
   (point? '(cons 36 -17)) ;; #f
   (point-x p) ;; 36
   (point-y p) ;; -17

   ;;; 默认字段值是不可变的(immutable)
   ;;; 要改变字段值需要将字段声明为可变(multable)
   (define-record-type point (fields (mutable x) y))
   ;;; 声明为mutable后，会增加一个改变x值的过程(mutator)
   ;;; (point-x-set! p x)
   (define p (make-point 36 -17))
   (point-x-set! p (- (point-x p) 12))
   (point-x p) ;; 24

   ;;; 为清楚起见，可以明确声明字段是不可变的(immutable);
   (define-record-type point (fields (mutable x) (immutable y)))

   ;;; 自定义相关过程标识符，构造器、谓词、访问器、存取器
   ;;;                      structtor predate
   (define-record-type (point mkpoint ispoint?)
     ;;                accessor mutators
     (fields (mutable x x-val set-x-val!)
             (immutable y y-val)))

   ;;; 嵌套调用，注意内部f生成的p,和外部f比较的point?不是一个类型
   ;;; 每次调用define-record-type 都将生成新的类型定义，即便是一样的内容
   ;;; 
   (define (f p)
     (define-record-type point (fields x y))
     (if (eq? p 'make) (make-point 3 4) (point? p)))
   (f (f 'make)) ;; #f
   ;; 注意后缀的不同， *-1，*-2，*-3，*-4说明调研了4次define-record-type
   ;; 不同生成器生成的point是不同的类型
   ;;> #[#{point ha8e477qifvlwrgqvn81cukto-1} 3 4]
   ;;> #[#{point ha8e477qifvlwrgqvn81cukto-2} 3 4]
   ;;> #[#{point ha8e477qifvlwrgqvn81cukto-3} 3 4]
   ;;> #[#{point ha8e477qifvlwrgqvn81cukto-4} 3 4]

   ;;; nongenerative 与 fields 顺序可以调换
   ;;; 不产生新定义类型
   (define (f p)
     (define-record-type point (fields x y) (nongenerative))
     (if (eq? p 'make) (make-point 3 4) (point? p)))
   (define p (f 'make))
   (f p) ;; #t

   ;;; 在不同的词法域内，即便使用(nongenerative)，也是不同的类型定义
   (define (f)
     (define-record-type point (fields x y) (nongenerative))
     (make-point 3 4))
   (define (g p)
     (define-record-type point (fields x y) (nongenerative))
     (point? p))
   (g (f)) ;; #f

   ;;; 使用(nongenerative <user-id>)来指定不同词法域的相同记录类型
   (define (f)
     (define-record-type point (fields x y)
       (nongenerative really-the-same-point))
     (make-point 3 4))
   (define (g p)
     (define-record-type point (fields x y)
       (nongenerative really-the-same-point))
     (point? p))
   (g (f)) ;; #t
   (f)     ;; #[really-the-same-point 3 4] 使用用户自定义记录名称

   ;;; 父子类型
   ;;; 继承
   (define-record-type point (fields x y))
   (define-record-type cpoint (parent point) (fields color)) ;;; 带颜色的点
   ;;(define-record-type car (fields color))
   ;;(define-record-type point-car (parent point) (parent car) (fields title)) 不支持多继承
   (define aaa
     (make-cpoint 3 4 'red))
   aaa
   (point? aaa)    ;; #t 子类实例是父类型
   (cpoint? aaa)   ;; #t
   (point-x aaa)   ;; 3
   ;; (cpoint-x aaa) 注意不存在cpoint-x,子类不会重复定义父类的访问器
   (cpoint-color aaa) ;; 子类只是增加新的访问器(方法)

   ;;--------------------------------------------------------------------------------
   ;; protocol 协议赋值
   ;; 
   (define-record-type point
     (fields x y d)
     (protocol
      ;;;原始构造器接收x,y,d三参数
      (lambda (new)
        ;;; 新构造器接受2参数
         (lambda (x y)
           (new x y (sqrt (+ (* x x) (* y y)))))))) 

   (define p (make-point 3 4))
   (point-x p) ;; 3
   (point-y p) ;; 4
   (point-d p) ;; 5

   ;;; 带继承的情况
   (define-record-type cpoint
     (parent point)
     (fields color)
     (protocol
       (lambda (pargs->new)
         (lambda (c x y)
           ((pargs->new x y) c))))) 

   (define cp (make-cpoint 'red 3 4))
   (point-x cp) ;; 3
   (point-y cp) ;; 4
   (point-d cp) ;; 5
   (cpoint-color cp) ;; red
   #+END_SRC
   
*** syntax: (define-record-type record-name clause ...) 
    syntax: (define-record-type (record-name constructor pred) clause ...) 
    libraries: (rnrs records syntactic), (rnrs)
    
    记录定义，以<record-name>作为标识符，包含：谓词、构造器、访问器、存取器(mutator)；

*** Fields clause(字段条款)
    - (fields field-spec ...)
    - fields-spec
      field-name
      (immmutable field-name)
      (mutable field-name)
      (immmutable field-name accessor-name)
      (mutable field-name accessor-name mutator-name)
      
      default-accessor-name = <record-name>-<field-name>
      default-mutator-name = <record-name>-<field-name>-set!
*** Parent clause(父记录条款)
    (parent parent-name)
    父记录必须已申明(previoisly defined via define-record-type)非封闭(non-sealed)
    子记录属于父记录，但增加自己的内容。(子记录是父记录的超集)
*** Nongenerative clause(不新增定义条款)
    (generative)        ;; 保证每次调用均生成不同的uid，
    (nongenerative)     ;; 词法域内自定义uid，保证词法域内一致
    (nongenerative uid) ;; 全局定义记录uid，保证全局一致
*** Protocol clause(协议条款)
    - (protocol expression)
    - expression:
      计算结果是一个过程
*** Sealed clause(封闭条款)
    (seled #t)：指定记录不能扩展(不能作为父记录被继承)，不能被make-record-type-descriptor调用。
*** Opaque clause(不透明条款)
    (parent-rtd parent-rtd parent-rcd) 
    主要用途：当通过调用make-record-type-descriptor和make-record-constructor-descriptor获得父rtd和rcd。
*** 辅助句法关键字
    syntax: fields 
    syntax: mutable 
    syntax: immutable 
    syntax: parent 
    syntax: protocol 
    syntax: sealed 
    syntax: opaque 
    syntax: nongenerative 
    syntax: parent-rtd 
    libraries: (rnrs records syntactic), (rnrs)
** 9.2.Procedural Interface
   make-record-type-descriptor 创建更灵活的记录类型语法接口。
*** procedure: (make-record-type-descriptor name parent uid s? o? fields) 
    returns: a record-type descriptor (rtd) for a new or existing record type 
    libraries: (rnrs records procedural), (rnrs)
    
    #+BEGIN_SRC scheme
    (define point-rtd
      (make-record-type-descriptor 'point #f #f #f #f
                                   '#((mutable x) (immutable y))))
    (define point-rcd
      (make-record-constructor-descriptor point-rtd
                                          #f #f))
    (define make-point (record-constructor point-rcd))
    (define point? (record-predicate point-rtd))
    (define point-x (record-accessor point-rtd 0))
    (define point-y (record-accessor point-rtd 1))
    (define point-x-set! (record-mutator point-rtd 0))

    ;; ...
    #+END_SRC

** 9.x.summary
   - 需求
       一个复杂对象需要由多个基本数据类型描述，于是就需要一个能表达复杂对象的机制；
       记录就被设计出来；
     - 需要一个标识符来标识一个记录，name
     - 需要一个谓词来判断该对象是否为一个记录对象，predicate
       由于scheme的语言特性决定，需要用谓词来判断对象类型，进而确定对象特性；
     - 支持多个种类型组合
       - 需要 field (字段)概念
         - 字段需要 字段名称
         - 访问器
     - 需要一个构造器来构造一个记录示例；
     - 需要一个定义器来定义记录；
     - 支持父类
     - 支持UUID
     - 至此缺省构造参数
       
   - 设计
     - 定义器
       (define-record-type (record-name constructor pred) clause ...)
       - define-record-types
         - record-name
           - constructor
           - predicate
         - cluase
           - fields
             (fields [immmutable|mutale] <field-name> [accser-name] [mutator-name])
             - immultable ; 不可修改
             - multable ; 可修改
             - accerror-name ; 访问器
             - mutator-name ; 赋值器
           - parent
             (parent parent-name) ; 父类
           - nongenerative ; UUID
             - <none> ; 每个定义产生一个UUID
             - (nongenerative) ; 作用于内不产生新UUID
             - (nongenerative <user-uuid>) ; 全局使用<user-uuid>
           - protocol ; 构造仪式
           - sealed ; 密封的,标记不可被扩展，即不可作为父类
             (sealed [#f|#t])
           - opaque ; 不透明的， 不可被谓词判断record?
           - parent-rtd
             (parent-rtd parent-rtd parent-rcd)
             (make-record-type-descriptor)
             (make-record-constructor-descriptor)
       - (make-record-type-descriptor name parent uid s? o? fields)
         more flexibility than (define-record-type)
         but *lead less readable and efficient programs*
         if (define-record-type) suffices, don't use (make-record-type-descriptor)
     - inspection
       - (record-type-name rtd)
         #+BEGIN_SRC scheme
         (define record->name
           (lambda (x)
             (if (record? x)
                 (record-type-name (record-rtd x))
                 #f)))
         (define-record-type dim (fields w l h))
         (record->name (make-dim 10 15 6))
         (define-record-type dim (fields w l h) (opaque #t))
         (record->name (make-dim 10 15 6))
         #+END_SRC
       - (record-type-parent rtd)
         procedure, return the parent of trd, or #f if it has no parent
         #+BEGIN_SRC scheme
         (define-record-type point (fields x y))
         (define-record-type cpoint (parent point) (fields color))
         (record-type-parent (record-type-deacriptor point))
         (record-type-parent (record-type-descriptor cpoint))
         #+END_SRC
       - (record-type-uid rtd)
         #+BEGIN_SRC scheme
         (define-record-type point (fields x y))
         (define-record-type cpoint
           (parent point)
           (fields color)
           (nongenerative user-defined-uuid-111-222))
         (record-type-uid (record-type-descriptor point)) ;=> #{point n7hnxzdqr3i735efe2pue5ze7-0}
         (record-type-uid (record-type-descriptor cpoint)) ;=> user-defined-uuid-111-222
         #+END_SRC
       - (record-type-generative? rtd)
       - (record-type-sealed? rtd)
       - (record-type-opaque? rtd)
       - (record-type-field-names rtd)
       - (record-field-mutable? rtd idx)
       - (record? obj)
       - (record-rtd record)
     - 特性
       - 默认：每个相同名词的记录，均采用不同的UUID标识不同的类型；
       - (nongenerative) : 相同作用域内的定义，不产生新的UUID
       - (nongenerative user-def-uuid) : 全局采用统一的UUID
       - (parent pname) :支持父类
       - (protocol ) : 支持重定义构造参数,解耦合父子间的构造器，可以父类和独立演变
               
   - 示例
     #+BEGIN_SRC scheme
     ;;; name: point
     ;;; fields: x y
     ;;; implicity interfaces:
     ;;; constructor: (make-point x y) ; make-<record-name>
     ;;; predicate: (point? obj)       ; <record-name>?
     ;;; accessor: (point-x p)         ; <record-name>-<field-name>
     (define-record-type point (fields x y))

     ;;; Use constructor procedure to make point instance.
     (define p (make-point 36 -17))
     (point? p) ;=> #t
     (point? (cons 36 -17)) ;=> #f
     (point-x p) ;=> 36
     (point-x-set! p 16)
     (point-x p) ;=> 16
     (compute-size p) ;=> 752
     (compute-size point-x) ;=> 1312
     (compute-size point?) ;=> 1120

     ;;; 重定义完整的point
     (define-record-type (point make-point point?)
       (fields (mutable x point-x point-x-set!)
               (immutable y point-y))
       (nongenerative really-the-same-point))
     make-point
     ;;; test (nongenerative ...)
     (define (f p)
       (define-record-type point (fields x y))
       (if (eq? p 'make) (make-point 3 4) (point? p)))
     (f (f 'make)) ;=> #f
     (define (f p)
       (define-record-type point (fields x y) (nongenerative))
       (if (eq? p 'make) (make-point 3 4) (point? p)))
     (define p (f 'make))
     (f p) ;=> #t


     ;;; test (nongenerative user-uuid)
     (define (f)
       (define-record-type point (fields x y) (nongenerative))
       (make-point 3 4))
     (define (g p)
       (define-record-type point (fields x y) (nongenerative))
       (point? p))
     (g (f)) ;=> #f

     (define (f)
       (define-record-type point (fields x y)
         (nongenerative really-the-same-point))
       (make-point 3 4))
     (define (g p)
       (define-record-type point (fields x y)
         (nongenerative really-the-same-point))
       (point? p))
     (g (f)) ;=> #t

     ;;; clause parent
     (define-record-type point (fields x y))
     (define-record-type cpoint (parent point) (fields color))
     (define cp (make-cpoint 3 4 'red))
     (point? cp)
     (cpoint? cp)
     (point-x cp)
     (point-y cp)
     (cpoint-color cp)

     ;;; override default and specify the arguments to the constructor
     ;;; protocol clause
     (define-record-type point
       (fields x y d)
       (protocol
        (lambda (new)
          (lambda (x y)
            (new x y (sqrt (+ (* x x) (* y y)))))))
       ;; 不支持多protocol
       #;
       (protocol
        (lambda (new)
          (lambda ()
            (new 3 4 5)))))
     (define p (make-point 3 4))
     (point-x p)
     (point-y p)
     (point-d p) ;=> 5

     ;;; has parent
     (define-record-type cpoint
       (parent point)
       (fields color)
       (protocol
         (lambda (pargs->new)
           (lambda (c x y)
             ((pargs->new x y) c))))) 

     (define cp (make-cpoint 'red 3 4))
     (point-x cp) ;=> 3
     (point-y cp) ;=> 4
     (point-d cp) ;=> 5
     (cpoint-color cp) ;=> red
     ;; 只能有一个构造器
     ;; (define cp (make-cpoint 4 3 'black))
     (define-record-type cwpoint
       (parent cpoint)
       (fields weight)
       (protocol (lambda (new)
                   (lambda (w c x y)
                     ;;; 深层继承，只关心父类构造函数
                     ((new c x y) w)))))
     (define cwp (make-cwpoint 12 'black 3 4))
     (cwpoint-weight cwp)
     #+END_SRC
* 10. Libraries and Top-Level
  库使用带括号的语法命名，该语法包含一系列标识符，可选地后跟一个版本;
  实现通常将名称序列视为可以找到库的源代码或目标代码的路径，可能根源于主机文件系统中的某些标准位置集。
  
** 10.1.Standard Libraries
  #+BEGIN_SRC scheme
  (rnrs base (6))
  (rnrs arithmetic bitwise (6))
  (rnrs arithmetic fixnums (6))
  (rnrs arithmetic flonums (6))
  (rnrs bytevectors (6))
  (rnrs conditions (6))
  (rnrs control (6))
  (rnrs enums (6))
  (rnrs eval (6))
  (rnrs exceptions (6))
  (rnrs files (6))
  (rnrs hashtables (6))
  (rnrs io ports (6))
  (rnrs io simple (6))
  (rnrs lists (6))
  (rnrs mutable-pairs (6))
  (rnrs mutable-strings (6))
  (rnrs programs (6))
  (rnrs r5rs (6))
  (rnrs records procedural (6))
  (rnrs records syntactic (6))
  (rnrs records inspection (6))
  (rnrs sorting (6))
  (rnrs syntax-case (6))
  (rnrs unicode (6))
  #+END_SRC

** 10.2.Define New Libraryes
   - (library library-name
     + (identifier identifier ...)
     + (identifier identifier ... version)
       - (subversion ...)
         nonnegative inteter
   - (export export-spec ...)
     + identifier
     + (rename (internal-name export-name) ...)
   - (import import-spec ...)
     + import-set
       - library-spec
         - library-reference
           (identifier identifier)
           (identifier identifier ... version-reference)
           + version-reference
             - (subversion-reference1 ... subversion-referencen)
               + subversion
                 - (>= subversion)
                 - (<= subversion)
                 - (and subversion-reference ...)
                 - (or ...)
                 - (not subversion-reference)
                 - example
                   (1 2) (1 3 1)
                   () (1) => (1 2) (1 3 1)
                   (1 (>=2)) => (1 2) (1 3 1)
                   (1 (>=3) (not (1 3 1))) => matches neither
             - (and version-reference ...)
             - (or version-reference ...)
             - (not version-reference)
         - (library library-reference)
       - (only import-set identifier ...)
       - (except import-set identifier ...)
       - (prefix import-set prefix)
         - example
           #+BEGIN_SRC scheme
           (prefix
             (only ;; 只导入union,diff
               (rename (list-tools setops) (difference diff)) ;; 重命名difference 为 diff
               union
               diff)
             set:) ;; 前缀 set:
           #+END_SRC
       - (rename import-set (import-name internal-name) ...)
     + (for import-set import-level ...)
       - import-level
         + run ; and (meta 0) are equivalent
         + expand ; and (meta 1) are equivalent
         + (meta level)
           - level represents an exact integer
   - library-body)

   #+BEGIN_SRC scheme
   ;;; 定义库
   ;;; 关键字 library， 库名 library-name
   (library library-name
     (export export-spec ...)
     (import import-spec ...)
     library-body)

   ;;; library-name
   (identifier identifier ...)
   (identifier identifier ... version)
   ;;; version
   (subversion ...)
   ;;; subversion
   'nonegative-integer

   ;;; export-spec
   'identifer
   (rename (internal-name export-name) ...)
   ;;; internal-name, export-name is identifier


   #+END_SRC
*** define liarary form syntax
    #+BEGIN_SRC scheme
    ;;; 自定义库
    (library library-name
      (export export-spec ...) ;; 导出库
      (import import-spec ...) ;; 导入库
      library-body)

    ;;; 定位库路径
    (identifier identifier ...)
    (identifier identifier ... version)

    (subversion ...)

    (list-tools setops) ;; = (list-tools setops ())
    (list-tools setops (1 2)) ;; = version 1.2

    ;;; export-spec
    identifier ;; internal-name == export-name
    (rename (internal-name export-name) ...)

    ;;; import-spec
    import-set
    (for import-set import-level ...)
    ;;; import-level, level 是正整数
    run
    expand
    (meta level)

    library-spec
    (only import-set identifier ...)
    (except import-set identifier ...)
    (prefix import-set prefix)
    (rename import-set (import-name internal-name) ...)

    (prefix
      (only
        (rename (list-tools setops) (difference diff))
        union
        diff)
      set:)
    #+END_SRC

** 10.3.Top-Level Programs
    顶级程序本身不是语法形式，而是一组通常仅由文件边界分隔的forms。
    顶级程序可以被认为是没有库包装器的库forms;
    (import import-spec ...)
    definition-or-expression
    ...
      
**** procedure: (command-line) 
     returns: a list of strings representing command-line arguments 
     libraries: (rnrs programs), (rnrs)
     
   #+BEGIN_SRC scheme
   ;;; 获取程序输入参数
   (command-line)
   #+END_SRC

**** procedure: (exit) 
     procedure: (exit obj) 
     returns: does not return 
     libraries: (rnrs programs), (rnrs)
     
     退出程序，回到操作系统
     
** 10.4.Examples
   #+BEGIN_SRC scheme
   ;;; 自定义 list-tools setops v.1 库
   (library (list-tools setops (1))
     (export set empty-set empty-set? list->set set->list
             union intersection difference member?)
     (import (rnrs base) (only (rnrs lists) member)) 

     (define-syntax set
       (syntax-rules ()
         [(_ x ...)
          (list->set (list x ...))])) 

     (define empty-set '()) 

     (define empty-set? null?) 

     (define list->set
       (lambda (ls)
         (cond
           [(null? ls) '()]
           [(member (car ls) (cdr ls)) (list->set (cdr ls))]
           [else (cons (car ls) (list->set (cdr ls)))]))) 

     (define set->list (lambda (set) set)) 

     (define u-d-help
       (lambda (s1 s2 ans)
         (let f ([s1 s1])
           (cond
             [(null? s1) ans]
             [(member? (car s1) s2) (f (cdr s1))]
             [else (cons (car s1) (f (cdr s1)))])))) 

     (define union
       (lambda (s1 s2)
         (u-d-help s1 s2 s2))) 

     (define intersection
       (lambda (s1 s2)
         (cond
           [(null? s1) '()]
           [(member? (car s1) s2)
            (cons (car s1) (intersection (cdr s1) s2))]
           [else (intersection (cdr s1) s2)]))) 

     (define difference
       (lambda (s1 s2)
         (u-d-help s1 s2 '()))) 

     (define member-help?
       (lambda (x s)
         (and (member x s) #t))) 

     (define-syntax member?
       (syntax-rules ()
         [(_ elt-expr set-expr)
          (let ([x elt-expr] [s set-expr])
            (and (not (null? s)) (member-help? x s)))])))

   (library (more-setops)
     (export quoted-set set-cons set-remove)
     (import (list-tools setops) (rnrs base) (rnrs syntax-case)) 

     (define-syntax quoted-set
       (lambda (x)
         (syntax-case x ()
           [(k elt ...)
            #`(quote
                #,(datum->syntax #'k
                    (list->set
                      (syntax->datum #'(elt ...)))))]))) 

     (define set-cons
       (lambda (opt optset)
         (union (set opt) optset))) 

     (define set-remove
       (lambda (opt optset)
         (difference optset (set opt)))))


   (import
     (for (list-tools setops) expand run)
     (for (rnrs base) expand run)
     (for (rnrs syntax-case) expand))

   (import (list-tools setops) (more-setops) (rnrs))
   (define-syntax pr
     (syntax-rules () 
       [(_ obj)
        (begin
          (write 'obj)
          (display " ;=> ")
          (write obj)
          (newline))]))
   (define get-set1
     (lambda ()
       (quoted-set a b c d)))
   (define set1 (get-set1))
   (define set2 (quoted-set a c e)) 

   (pr (list set1 set2))
   (pr (eq? (get-set1) (get-set1)))
   (pr (eq? (get-set1) (set 'a 'b 'c 'd)))
   (pr (union set1 set2))
   (pr (intersection set1 set2))
   (pr (difference set1 set2))
   (pr (set-cons 'a set2))
   (pr (set-cons 'b set2))
   (pr (set-remove 'a set2))
   #+END_SRC

* 11. Exceptions and Conditions
  异常和信号为系统和用户代码提供了，发送信号，检测，错误恢复的方法。
  - 异常由标准语法抛出
  - 异常由用户通过(raise,raise-continuable)抛出
  - current exception handler 处理所有异常，默认异常处理是打印异常，退出程序；
  - 用户代码可以通过guard语法或with-exception-handler过程建立新的当前异常处理程序。
    异常处理链。
** 11.1.Raising and Handling Exceptions
*** procedure: (raise obj) 
    procedure: (raise-continuable obj) 
    returns: see below 
    libraries: (rnrs exceptions), (rnrs)
    
    异常处理程序可以返回（具有零个或多个值）继续可持续异常(continuable)。
    但是，如果异常处理程序尝试返回到非可持续异常的延续，则会引发具有条件类型和不可持续性的新异常。
    #+BEGIN_SRC scheme
    (raise
      (condition
        (make-error)
        (make-message-condition "no go"))) ;;=> error: no go
    (raise-continuable
      (condition
        (make-violation)
        (make-message-condition "oops"))) ;;=> violation: oops
    (list
      (call/cc
        (lambda (k)
          (vector
            (with-exception-handler
              (lambda (x) (k (+ x 5)))
              (lambda () (+ (raise 17) 8))))))) ;;=> (22)
    (list
      (vector
        (with-exception-handler
          (lambda (x) (+ x 5))
          (lambda () (+ (raise-continuable 17) 8))))) ;;=> (#(30))
    (list
      (vector
        (with-exception-handler
          (lambda (x) (+ x 5))
          (lambda () (+ (raise 17) 8))))) ;;=> violation: non-continuable

    #+END_SRC
*** procedure: (error who msg irritant ...) 
    procedure: (assertion-violation who msg irritant ...) 
    libraries: (rnrs base), (rnrs)
*** syntax: (assert expression) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (syntax-violation who msg form) 
    procedure: (syntax-violation who msg form subform) 
    returns: does not return 
    libraries: (rnrs syntax-case), (rnrs)
*** procedure: (with-exception-handler procedure thunk) 
    returns: see below 
    libraries: (rnrs exceptions), (rnrs)
    #+BEGIN_SRC scheme
    (with-exception-handler
     ;; procedure - exception handler
     (lambda (condition)
       (display condition)
       ;; ...
       )
     ;; thunk - exception procedure
     (lambda ()
       ;; ...
       (error 'test "throw error test" '(irritants))
       )
     )
    #+END_SRC
    
    #+BEGIN_SRC scheme
    (define (try thunk)
      (call/cc
        (lambda (k)
          (with-exception-handler
            (lambda (x) (if (error? x) (k #f) (raise x)))
            thunk))))
    (try (lambda () 17)) ;;=> 17
    (try (lambda () (raise (make-error)))) ;;=> #f
    (try (lambda () (raise (make-violation)))) ;;=> violation
    (with-exception-handler
      (lambda (x)
        (raise
          (apply condition
            (make-message-condition "oops")
            (simple-conditions x))))
      (lambda ()
        (try (lambda () (raise (make-violation)))))) ;;=> violation: oops
    #+END_SRC
*** syntax: (guard (var clause1 clause2 ...) b1 b2 ...) 
    returns: see below 
    libraries: (rnrs exceptions), (rnrs)

    #+BEGIN_SRC scheme
    (guard (x [else x]) (raise "oops")) ;;=> "oops"
    (guard (x [#f #f]) (raise (make-error))) ;;=>  error
    (define-syntax try
      (syntax-rules ()
        [(_ e1 e2 ...)
         (guard (x [(error? x) #f]) e1 e2 ...)]))
    (define open-one
      (lambda fn*
        (let loop ([ls fn*])
          (if (null? ls)
              (error 'open-one "all open attempts failed" fn*)
              (or (try (open-input-file (car ls)))
                  (loop (cdr ls)))))))
    ; say bar.ss exists but not foo.ss:
    (open-one "foo.ss" "bar.ss") ;;=> #<input port bar.ss>
    #+END_SRC
** 11.2.Defining Condition Types
   虽然程序可以传递raise或raise-continuable任何Scheme值，但描述异常情况的最佳方法通常是创建并传递条件对象。
   - simple condition   ; single condition types
   - compound condition ; multiple condition types
   - syntax:&condition
     a record-type name and the root of the condition-type hierarchy.
   - procedure:(condition condition ...)
     condition is used to create condition objects that may consist of multiple simple conditions.
     Each argument condition may be simple or complex;
     if simple, it is treated as a compound with itself as tis only simple condition.
     The simple onditions of the result condition are the simple conditions of the condition arugments,
     flattened into single list and appearing in order, with the simple conditions of the first condition
     followed by the simple conditions of the second, and so on.
     If the list has exactly one element, the result condtion may be simple or compound;
*** procedure:(simple-conditions condition)
    returns: a list of the simple conditions of condition
*** syntax:(define-condition-type name parent constructor pred field ...)
    - name,parent,... ;identifiers
    - field ;(field-name accessor-name)
      + field-name ; identifier
      + accessor-name ; identifier
   #+BEGIN_SRC scheme
   ;;(&condition)
   (condition? cons)  ;=> #f
   (condition? (make-error)) ;=> #t
   (condition? (make-message-condition "oops")) ;=> #t
   (condition? (condition
                (make-error)
                (make-message-condition "no such element"))) ;=> #t
   ;;; procedure: (condition condition ...)
   ;;; returens: a condition, possible compound
   ;;; libraries: (rnrs conditions),(rnrs)
   (condition)
   (condition (make-error)
              (make-message-condition "oops")) ;=> compound condition
   (define-record-type (&xcond make-xcond xcond?) (parent &condition))
   (xcond? (make-xcond)) ;=> #t
   (xcond? (condition (make-xcond))) ;=> #t
   (xcond? (condition)) ;=>#f
   (xcond? (condition (make-error) (make-xcond))) ;=>#f

   ;;; (simple-conditions condition)
   (simple-conditions (condition))
   (simple-conditions (make-error))
   (simple-conditions (condition (make-error))) ;=>(#<condition &error>)
   (simple-conditions (condition (make-error)
                                 (make-message-condition "oops"))) ;=>(#<condition &error> #<condition &message)
   (let ([c1 (make-error)]
         [c2 (make-who-condition "f")]
         [c3 (make-message-condition "invalid arugments")]
         [c4 (make-message-condition "error occurred while reading from file")]
         [c5 (make-irritants-condition '("a.ss"))])
     (equal? (simple-conditions
              (condition (condition (condition c1 c2) c3)
                         (condition c4 (condition c5))))
             (list c1 c2 c3 c4 c5))) ;=> #t

   ;;; (define-condition-type ...)
   (define-condition-type &mistake &condition make-mistake mistake?
     (type mistake-type))
   (mistake? 'booooo) ;=> #f
   (define c1 (make-mistake 'spelling))
   (mistake? c1)
   (mistake-type c1)
   (define c2 (condition c1 (make-irritants-condition '(eggregius))))
   (mistake? c2) ;=> #t
   (mistake-type c2) ;=> spelling
   (irritants-condition? c2) ;=> #t
   (condition-irritants c2) ;=> (eggregius)
   #+END_SRC
** 11.3.Standard Condition Types
   - &serious ; 严重
     (make-serious-condition)
     (serious-condition? obj)
   - &violation ; 违例
     Conditions of this type indicate that the program has violated some requirement, 
     usually due to a bug in the program.
   - &assertion ; 断言
     a specific violation in which the program has passed the wrong number or types of arguments
     to a procedure.
   - &error ; 错误
     error has occured with the program's interaction with its operating environment,
     such as the failure of an attempt to open a file.
   - &warning ; 警告
     do not prevent the program continuing its execution but, in some cases, might result in a
     more serous problem at some later point.
   - &message ; 消息
     usually included with a &warning condition or one of the &serious
   - &irritants ; 刺激物，诱发因素
     usually included with a &message condition
   - &who ; 谁发出的
     usually included with a &message condition
     identify the syntactic form or procedure that detected the error.
     a symbol or string.
   - &non-continuable ; 不可继续
     a non-continuable violation has occurred.
     raise
   - &implementation-restriction ; 超出范围
     attempted to exceed some limitation int the implementation.
   - &lexical ; 词法错误
     such as mismatched parentheses, an invalid character appearing within a numberic contant.
   - &syntax ; 语法错误
     most syntax errors are detected by the macro expander.
   - &undefined ; 未定义错误
   - &i/o
     Conditions of this type typically occur as one of the more specific subtypes described below.
   - &i/o-read
   - &i/o-write
   - &i/o-invalid-position
   - &i/o-filename
   - &i/o-file-protection
   - &i/o-file-is-read-only
   - &i/o-file-already-exists
   - &i/o-file-doesnot-exist
   - &i/o-port
     usually included with a condition of one of the other &i/o subtypes
   - &i/o-decoding
   - &i/o-encoding
   - &no-infinities
   - &no-nans

** 11.x.summary
   - 概念
     - exceptions 程序异常
     - conditions 异常描述对象
       当发生异常时，使用condition来表述一个异常，condition是可以组合的，用于增强condition的表达能力
       - &condition
         一个记录类型
         所有condition的父类
       - (define-condition-type name parent constructor pred field ...) ;自定义condition
       - 标准condition(异常状态记录)         
     - 抛出机制
       - raise ; 不可恢复异常
         不可恢复到捕获区域内的后续处继续执行
         - 便利封装
           - (error who msg irritant ...)
           - (assertion-violation who msg irritant ..)
           - (assertion expression)
           - (syntax-violation who msg form [subform])
       - raise-continuable ;可恢复异常
         可恢复到捕获区域内后续处继续执行
     - 捕获机制
       (生产(raise))       (调度)                    （消费）
       (body) --> (with-exception-handler/guard) --> (handler)
         \-<-------(raise-continuable)----------------/
       
       - (with-exception-handler procedure thunk)
         适合简单的捕获
       - (guard (condition clause1 clause2 ...) b1 b2 ...)
         复杂的捕获
   - 流程
     - 默认
       scheme 提供一个默认异常处理机制
     - 主动捕获处理
       - (with-exception-handler (lambda (condition) ...)
                                 (lambda () ...))
       - (guard (condition [(error? condition) ...]
                           [ ... ])
                exp1 exp2 ...)
   - 扩展
     - 实现一个异常状态描述库
       - 将异常状态格式化到流
       - 支持多种格式化类型
         - 字符串
         - Json
         - scheme-forms
     - 与日志系统有机集合
* 12. Extended Examples
** 12.11. Multitasking with Engines
   - use case
     multiprocession
     light-weight threads
     operating system kernels
     nondeterministic computations
   - ability
     timed preemption
   - usage
     - (make-engine ...)
       - ticks
         -type 正整数
         -desc 指定超时时中周期，要么超时，要么任务结束
       - complete
         - type 
           procedure of two arguments;2参数的过程
           - arg1
             the amount of fuel left over; 剩余时中
           - arg2
             the result of the computation; 计算结果
         - description what to do if the computation finishes;任务完成回调
       - expire
         - type
           procedure of one arguments;1参数过程
           - arg1
             a new capable of continuing the computation from the point of interruption;
             剩余任务的engine，engine可被继续分配时间片执行，直到完成任务。
         - description
           what to do if the fuel runs out before computation finishes;任务超时回调
   #+BEGIN_SRC scheme
   ;;; An engine is created by passing a chunk(procedure of no arguments) to the procedure make-engine
   ;;;
   (define engine-logic
     (lambda (ticks complete expire)
       (timer ticks)
       'do-tasks
       (if (task-done?)
           (complete left-ticks task-result)
           (expire new-engine))))

   ;;; engine usage
   (define fac-recur
     (lambda ()
       (let f [(x 100)]
         (if (= 0 x)
             1
             (* x (f (- x 1)))))))
   (define fac-recur-tail
     (lambda ()
       (let f ([x 100] [val 1])
         (if (= x 0)
             val
             (f (- x 1) (* val x))))))

   (define complete-engine
     (lambda (task ticks)
       (let loop ([engine (make-engine task)]
                  [ticks-count 0])
         (engine ticks
                 (lambda (ticks-left value)
                   (values value (+ ticks-count (- ticks ticks-left))))
                 (lambda (new-eng)
                   (display (/ ticks-count ticks)) (newline)
                   (loop new-eng (+ ticks ticks-count)))))))
   (complete-engine fac-recur-tail 10)
   (complete-engine fac-recur-tail 200)
   #+END_SRC

* chez-bee plans
** src
   - bee ; (library bee)
     - inspector ; object inspector
     - trace     ; logic trace, like log
     - system-extentions ; system inter face extentions
